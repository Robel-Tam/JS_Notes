{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JS Notes Good place to look back at important JS concepts you might have forgotten. Notes for the most part are taken from and follow the outline of a great JS reference Javascript.info , but also include good to know concepts and examples that might have been left out, below is a list of the referances used the most. References Javascript.info ECMAScript specs Eloquent Javacript a modern introduction to programming Secrets of the Javascript ninja Outline Code Quality Objects Data Types Advanced working with functions Object properties configuration Prototypes and Inheritance Contributing Feel free to submit a pull request, with anything from small fixes to new sections as this repo likely contains many typos, unclear abbreviations and so on.","title":"Home"},{"location":"#js-notes","text":"Good place to look back at important JS concepts you might have forgotten. Notes for the most part are taken from and follow the outline of a great JS reference Javascript.info , but also include good to know concepts and examples that might have been left out, below is a list of the referances used the most.","title":"JS Notes"},{"location":"#references","text":"Javascript.info ECMAScript specs Eloquent Javacript a modern introduction to programming Secrets of the Javascript ninja","title":"References"},{"location":"#outline","text":"Code Quality Objects Data Types Advanced working with functions Object properties configuration Prototypes and Inheritance","title":"Outline"},{"location":"#contributing","text":"Feel free to submit a pull request, with anything from small fixes to new sections as this repo likely contains many typos, unclear abbreviations and so on.","title":"Contributing"},{"location":"Advanced%20working%20with%20functions/","text":"Advanced working with functions The number of times a recursive function calls itself is called a recursion depth. The maximum recursion depth is limited by engines. read about Tail call optimizations Recursive structures - Linked lists let lList = { // a linked list value: 1, next:{ value: 2, next:{ value: 3, next: null } } } function printList(list){ // recursive function for printing elements inside the lList if(list.next == null) return list.value.toString(); return list.value.toString() + printList(list.next) } printList(lList) // 123 Rest parameters In JS it\u2019s ok to pass more arguments to a function that it need, the function will simply ignore it. To store the passed arguments to an array we can use rest parameters ( \u2026rest ). The rest parameter must come at the end if other parameters exist. function func( a, b, ...c) arguments object also contains all arguments passed by index function fun( a, b, c ) { console.log(arguments); console.log(arguments[1]); console.log(arguments.length); } fun(1,2,3,4); /* output [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4 } 2 4 */ The downside of the arguments object is that it\u2019s not an array, so we can\u2019t use array methods on it. Arrow functions don\u2019t have the arguments object, they will take it from an outer function if it exists Spread operator \ud83c\udf1f The syntax for the rest operator (\u2026arr) can also spread an iterable object in to a list of values. let str = \"hello\" let arr = [...str] // [\"h\",\"e\",\"l\",\"l\",\"o\"] // we can use this operator to pass arrays to functions expecting list of arguments arr = [ 1,2,3,4,5 ] Math.max(...arr) // 5 // we can also pass multiple iterables, and we can also combine them with non iterables arr2 = [ 6,7,8,9 ] Math.max(...arr, 34, ...arr2, 1) // 34 // we can use spread operators to merge arrays arr2 = [ ...arr2, ...arr1 ] Unlike the Array.from() method, the spread operator only operates on iterables and not array-likes, so Array.from() is a more universal way to convert stuff into arrays Closures Are functions that remember their outer variables and can access them. All JS functions are naturally closures. Lexical Environment A lexical environment is a specification (internal / hidden ) object associated with every function call / block / script. i.e. every running function/ block / script have their own. A lexical environment has two parts, environment record and reference to an outer lexical environment. An environment record - holds all the local variables as it\u2019s properties, and the value of this. therefore a variable is just a property of the internal object- environment record. // A visualization for lexical environments Lexical_Environment{ Environment_Record: { /*var1 : smth, ... */ }, Outer: /*null in the case of a global lexical env */ } let phrase; // { Environment_Record:{ phrase: undefined }, Outer: null } phrase = \"hello\"; // { Environment_Record:{phrase: \"hello\"}, Outer: null } phrase = \"bye\" ; // {Environment_Record:{pharse: \"bye\"}, Outer: null } Function declarations get initialized when the lexical environments that holds them gets created, unlike those with let , that get initialized when execution reaches it. That\u2019s why we can call functions before their declaration. All functions on birth get a hidden property [[Environment]] which contains a reference to the lexical environment of their creation. functions remember where they were created using this hidden property. // A visulization /* Execution starts -> { Env_record:{ greet: function }, Outer: null } */ let name = \"Jhon\" /* -> { Env_record:{ greet: function, name: \"Jhon\" }, Outer: null } */ function greet(title){ // [[Environment]] -> global lexical environment console.log(\"hello \" + title + \" \" + name); } Nested lexical environments : Let\u2019s call function greet greet(\"Mister\") // hello Mister Jhon // The execution environment created for this function call is /* [[Environment]] -> { Env_record:{ title: \"Mister\", }, Outer: /* A referance to the outer Lexical env with the value for name */ } */ When the code wants to access a variable, it\u2019s lexical environment is scanned first, if the variable is not found then the outer lexical environments are scanned progressively until it reaches the global lexical environment. That\u2019s how local variables override outer ones. \u26a0\ufe0f **Strict mode alert** If a variable is not found in any of the lexical environments, its an error in strict mode. But if we are not in strict mode, An assignment to an undefined variable creates a new global variable function f(){ b = 5 }; console.log(b) // 5 in non-strict mode // if we are in strict mode -This will throw a ReferanceError // if we are not, variable b will get created in the global context Nested Functions We can use them to organize code function printSquare(n){ function square(n) { return n * n; } console.log(square(n)); } We can use them inside constructors to create methods function User(name){ this.sayName = function(){ console.log(\"My name is \" + name; } } We can return the functions themselves function makeCounter(){ let count = 0; return function(){ return count++; } } let c = makeCounter(); let d = makeCounter(); c() // 0 c() // 1 d() // 0 When the first c() gets called, this happens c() [[Environment]] -> { Env_record:{}, Outer: -> { Env_record:{ count: 0, }, Outer: -> // global lexical env } } } Code Blocks, loops and IIFE Lexical environments can exist for any code block. A lexical environment is created when a block runs and contains block local variables if(true){ let v = 5; } v // ReferanceError // v can't be accessed from outside of the if blocks lexical environment Inside loops, every loop will have it\u2019s own lexical environment We can use a bare code block {} to isolate variables into a local scope. In a web browser all scripts except the ones with type=\u201dmodule\u201d share the same global area, So if we create a global variable in one script it will become available to the others, this may cause conflicts. But we can isolate each script by putting it inside its own block There used to be no block-level lexical environment in JS, so a work around called IIFE ( immediately invoked function expressions ) was used. (function (){ /* script */ })() // other ways ( function(){ /* script */ }() ) !function(){ /* script */ )() +function(){ /* script */ )() we use the parenthesis to say that the function is created in the context of another expression. The old var variables declared with var also have lexical environments that are bound to function scopes. function fun(){ let a = 1; var b = 2; } alert(a) // ReferanceError alert(b) // ReferanceError because vars are also bound to function scopes \ud83d\udce2 But unlike those declared with **let** and **const** they are not bound to block scopes. { let a = 1; var b = 2; } alert(a) // ReferanceError alert(b) // 2 var ignores code blocks // inside if blocks if(true){ var test = 4; } alert(test) // 4 // inside loops for( var i = 0; i < 10; i++); alert(i) // 9 \ud83d\udce2 **var** declarations get hoisted i.e. they get processed as soon as the script ( for global L.E ) or the function they are in gets executed. In other words their declaration gets moved up to the function or the script. Therefore we can use them before they get declared function greet(){ str = \"hello\"; if(false){ var str } console.log(str); } greet() // hello Declarations are hoisted but assignments are not function greet(){ console.log(str); var str = \"hello\" } greet() // undefined The global object Provides variables and functions that are available anywhere. Mostly the ones that are built into the language or the environment. In the browser it\u2019s name window , global in node. But globalThis has been added to the language as a standardized name for the global object. we can access members of the global object directly but it\u2019s good practice to refer to them through the global object. i.e. globalThis.x instead of x In-browser unless we\u2019re using modules, variables declared with var and global functions get added to the global object. We can use the global object to test for support of modern language features The function object Functions in JS are objects. So they have some usable properties of their own function f(){} Reflect.ownKeys(f) // [ 'length', 'name', 'arguments', 'caller', 'prototype' ] Reflect.ownKeys((a, b) => {}) // [ 'length', 'name' ] func. name : returns a read only name of the function function sayHi() {} sayHi.name // 'sayHi' let sayHi() = function(){} sayHi.name // 'sayHi' let user = { sayHi(){} } user.sayHi.name // 'sayHi' func. length : returns the number of arguments a function accepts function s( a, b, ...c){} s.length // 2 rest parameters are not counted custom properties we can add properties of our own to functions. // lets add a count property which stores the number of calls made to func function func(){ func.count++; console.log(func.count) } func.count = 0; func() // 1 func() // 2 func() // 3 Closures can sometimes be replaced with function properties // let's redo the makeCounter function with a custom property function makeCounter(){ function counter(){ return counter.count++; } counter.count = 0 ; reutrn counter; } let c = makeCounter(); c() // 0 c() // 1 c.count = 40; c() // 40 // In this case we can modify the counter Named function expressions ( NFE ) NFE is when we give names to the function on the right side of the function in our functional expressions. // normal functional expression let func = function() { } // NFE let func = function sayHi(){ } // NFE allows us to reference the function from within // the identifier sayHi isn't visible outside the function We use NFE when we want to reference the function from within the function. let sayHi = function func(ph){ if(ph) console.log(ph); else func(\"hello\"); } // We could have done let sayHi = function func(ph){ if(ph) console.log(ph); else sayHi(ph) } // but the above code will stop working if we change the value of sayHi let anotherFunc = sayHi; sayHi = null; anotherFunc(\"d\") // d anotherFunc() // Error sayHi is not a function // This happens because the identifier sayHi was taken from the outer L-Env // This can't be done with function declarations \ud83d\udce2 **Question** Write a function sum that would work like this: sum(1)(2) == 3; // 1 + 2 sum(1)(2)(3) == 6; // 1 + 2 + 3 sum(5)(-1)(2) == 6 new Function() syntax let func = new Function ([arg1, arg2, ...argN], functionBody); This syntax creates a function with arguments arg1 - argN with functionBody let func = new Function(functionBody) // a function without arguments Functions created with new Function() have an [[ Environment ]] referencing to the global Lex-Environment. This helps us to hide our local variables from them and to avoid running into problems when using minifiers. The arguments can also be given in a comma separated list. new Function(\"a\", \"b\", \"c\", \"alert(a)\" ); new Function(\"a,b\", \"c\", \"alert(a)\"); new Function(\"a,b,c\", \"alert(a)\" ) ; // all work the same Scheduling : setTimeout & setInterval These methods are not part of the JS specification. But most environments have an internal scheduler that provides these methods. setTimeout - causes a function or piece of code to run once after a period of time setInterval - causes a function to run regularly with the given interval // setTimeout( func, [delay] , [arg1], [arg2], [argn] ); delay in ms function sayHi(name){ console.log(`Hi ${name}` } let timerId = setTimeout(sayHi, 9000, \"Smith\"); // after 9 seconds => Hi Smith // a call to setTimeout returns a timerId we can use this to cancel it // setInterval(func, [delay], [arg1], [arg2], [argn] ); let timerId2 = setInterval(sayHi, 2000, \"Jack\" ); // Hi Jack will be displayed every 2 seconds canceling with clearTimeout and clearInterval clearTimeout( timerId ) clearInterval( timerId2 ) Recursive setTimeout There are two ways of running something regularly, using setInterval and with recursively calling setTimeout. let clock = setTimeout( function f(){ console.log(\"Tick Tok\"); setTimeout( f, 1000); }, 1000 ); This is a more flexible way because we can manipulate the delays. The recursive setTimout unlike setInterval guarantees the fixed delay ?? when a function is passed to setTimeout or setInterval, an internal reference to it is created and saved in the scheduler. This prevents the function from being garbage collected. But it also saved the outer lexical environment of the function, This might take much more memory than the function itself so when we don't need the scheduled function anymore it's better to cancel it. we can do that with clearTimeout and clearInterval Decorators and forwarding, call/apply Let's see how cool JS functions can be Transparent caching If we want to cache(remember) the results for different arguments of a CPU intensive function we can create a wrapper function like so. function slow(x){ // slow calculations return x; } function cachingDecorator(func){ let cache = new Map(); return function(x){ if(cache.has(x)){ return cache.get(x); } let result = func(x); cache.add(x, result; return result; } } let slowFunc = cachingDecorator(slow); slow(1) // got computed and cached slow(1) // returned from cache This code will fail if we try to pass Object methods to the wrapper and access properties that belong to the \"this\" context of that object. let obj = { method(){ return 1; } slow(x){ // kicka$$ code return x + this.method(); } } let obj.slow = cachingDecorator(obj.slow); // this will fail because this.method() will be undefined To overcome this problem we can use function.call() to pass the context as well. func.call() allows us to explicitly pass \"this\" func.call( context, arg1, arg2, ... ); // syntax for .call() function greet(){ console.log(`Hello my name is ${this.name}`); } let jack = {name: \"Jack Taylor\"} let bob = {name: \"Bob Smith\"} greet.call(jack)// Hello my name is Jack Taylor greet.call(bob) // Hello my name is Bob Smith So we can simply fix our wrapper function by changing the assignment to let result = func.call(this, x); We can also pass the context to a function call using func. apply( context, args) where args is an array like , we can use this when we want to pass an array like containing the multiple arguments for the function we are about to call. let args = [1, \"2\", 3]; func.apply(context, args); // the same effect can be acheived with func.call(context, ...args); // But func.apply() can get optimized better by engines func.apply() doesn't accept iterables only array likes. \u26a0 **read about method borrowing** spy decorator \u2753 **Good Question** Create a decorator delay(f, ms) that delays each call of f by ms milliseconds. page# 383 function print(a) { console.log(a) } let f3000 = delay(print, 3000); f3000(\"hello\") // prints hello after 3 seconds Topics I have to look into again Function binding Currying and partials Arrow functions revisited Every thing from page 355 onward","title":"Advanced working with functions"},{"location":"Advanced%20working%20with%20functions/#advanced-working-with-functions","text":"The number of times a recursive function calls itself is called a recursion depth. The maximum recursion depth is limited by engines. read about Tail call optimizations Recursive structures - Linked lists let lList = { // a linked list value: 1, next:{ value: 2, next:{ value: 3, next: null } } } function printList(list){ // recursive function for printing elements inside the lList if(list.next == null) return list.value.toString(); return list.value.toString() + printList(list.next) } printList(lList) // 123","title":"Advanced working with functions"},{"location":"Advanced%20working%20with%20functions/#rest-parameters","text":"In JS it\u2019s ok to pass more arguments to a function that it need, the function will simply ignore it. To store the passed arguments to an array we can use rest parameters ( \u2026rest ). The rest parameter must come at the end if other parameters exist. function func( a, b, ...c) arguments object also contains all arguments passed by index function fun( a, b, c ) { console.log(arguments); console.log(arguments[1]); console.log(arguments.length); } fun(1,2,3,4); /* output [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4 } 2 4 */ The downside of the arguments object is that it\u2019s not an array, so we can\u2019t use array methods on it. Arrow functions don\u2019t have the arguments object, they will take it from an outer function if it exists","title":"Rest parameters"},{"location":"Advanced%20working%20with%20functions/#spread-operator","text":"The syntax for the rest operator (\u2026arr) can also spread an iterable object in to a list of values. let str = \"hello\" let arr = [...str] // [\"h\",\"e\",\"l\",\"l\",\"o\"] // we can use this operator to pass arrays to functions expecting list of arguments arr = [ 1,2,3,4,5 ] Math.max(...arr) // 5 // we can also pass multiple iterables, and we can also combine them with non iterables arr2 = [ 6,7,8,9 ] Math.max(...arr, 34, ...arr2, 1) // 34 // we can use spread operators to merge arrays arr2 = [ ...arr2, ...arr1 ] Unlike the Array.from() method, the spread operator only operates on iterables and not array-likes, so Array.from() is a more universal way to convert stuff into arrays","title":"Spread operator \ud83c\udf1f"},{"location":"Advanced%20working%20with%20functions/#closures","text":"Are functions that remember their outer variables and can access them. All JS functions are naturally closures.","title":"Closures"},{"location":"Advanced%20working%20with%20functions/#lexical-environment","text":"A lexical environment is a specification (internal / hidden ) object associated with every function call / block / script. i.e. every running function/ block / script have their own. A lexical environment has two parts, environment record and reference to an outer lexical environment. An environment record - holds all the local variables as it\u2019s properties, and the value of this. therefore a variable is just a property of the internal object- environment record. // A visualization for lexical environments Lexical_Environment{ Environment_Record: { /*var1 : smth, ... */ }, Outer: /*null in the case of a global lexical env */ } let phrase; // { Environment_Record:{ phrase: undefined }, Outer: null } phrase = \"hello\"; // { Environment_Record:{phrase: \"hello\"}, Outer: null } phrase = \"bye\" ; // {Environment_Record:{pharse: \"bye\"}, Outer: null } Function declarations get initialized when the lexical environments that holds them gets created, unlike those with let , that get initialized when execution reaches it. That\u2019s why we can call functions before their declaration. All functions on birth get a hidden property [[Environment]] which contains a reference to the lexical environment of their creation. functions remember where they were created using this hidden property. // A visulization /* Execution starts -> { Env_record:{ greet: function }, Outer: null } */ let name = \"Jhon\" /* -> { Env_record:{ greet: function, name: \"Jhon\" }, Outer: null } */ function greet(title){ // [[Environment]] -> global lexical environment console.log(\"hello \" + title + \" \" + name); } Nested lexical environments : Let\u2019s call function greet greet(\"Mister\") // hello Mister Jhon // The execution environment created for this function call is /* [[Environment]] -> { Env_record:{ title: \"Mister\", }, Outer: /* A referance to the outer Lexical env with the value for name */ } */ When the code wants to access a variable, it\u2019s lexical environment is scanned first, if the variable is not found then the outer lexical environments are scanned progressively until it reaches the global lexical environment. That\u2019s how local variables override outer ones. \u26a0\ufe0f **Strict mode alert** If a variable is not found in any of the lexical environments, its an error in strict mode. But if we are not in strict mode, An assignment to an undefined variable creates a new global variable function f(){ b = 5 }; console.log(b) // 5 in non-strict mode // if we are in strict mode -This will throw a ReferanceError // if we are not, variable b will get created in the global context","title":"Lexical Environment"},{"location":"Advanced%20working%20with%20functions/#nested-functions","text":"We can use them to organize code function printSquare(n){ function square(n) { return n * n; } console.log(square(n)); } We can use them inside constructors to create methods function User(name){ this.sayName = function(){ console.log(\"My name is \" + name; } } We can return the functions themselves function makeCounter(){ let count = 0; return function(){ return count++; } } let c = makeCounter(); let d = makeCounter(); c() // 0 c() // 1 d() // 0 When the first c() gets called, this happens c() [[Environment]] -> { Env_record:{}, Outer: -> { Env_record:{ count: 0, }, Outer: -> // global lexical env } } } Code Blocks, loops and IIFE Lexical environments can exist for any code block. A lexical environment is created when a block runs and contains block local variables if(true){ let v = 5; } v // ReferanceError // v can't be accessed from outside of the if blocks lexical environment Inside loops, every loop will have it\u2019s own lexical environment We can use a bare code block {} to isolate variables into a local scope. In a web browser all scripts except the ones with type=\u201dmodule\u201d share the same global area, So if we create a global variable in one script it will become available to the others, this may cause conflicts. But we can isolate each script by putting it inside its own block There used to be no block-level lexical environment in JS, so a work around called IIFE ( immediately invoked function expressions ) was used. (function (){ /* script */ })() // other ways ( function(){ /* script */ }() ) !function(){ /* script */ )() +function(){ /* script */ )() we use the parenthesis to say that the function is created in the context of another expression.","title":"Nested Functions"},{"location":"Advanced%20working%20with%20functions/#the-old-var","text":"variables declared with var also have lexical environments that are bound to function scopes. function fun(){ let a = 1; var b = 2; } alert(a) // ReferanceError alert(b) // ReferanceError because vars are also bound to function scopes \ud83d\udce2 But unlike those declared with **let** and **const** they are not bound to block scopes. { let a = 1; var b = 2; } alert(a) // ReferanceError alert(b) // 2 var ignores code blocks // inside if blocks if(true){ var test = 4; } alert(test) // 4 // inside loops for( var i = 0; i < 10; i++); alert(i) // 9 \ud83d\udce2 **var** declarations get hoisted i.e. they get processed as soon as the script ( for global L.E ) or the function they are in gets executed. In other words their declaration gets moved up to the function or the script. Therefore we can use them before they get declared function greet(){ str = \"hello\"; if(false){ var str } console.log(str); } greet() // hello Declarations are hoisted but assignments are not function greet(){ console.log(str); var str = \"hello\" } greet() // undefined","title":"The old var"},{"location":"Advanced%20working%20with%20functions/#the-global-object","text":"Provides variables and functions that are available anywhere. Mostly the ones that are built into the language or the environment. In the browser it\u2019s name window , global in node. But globalThis has been added to the language as a standardized name for the global object. we can access members of the global object directly but it\u2019s good practice to refer to them through the global object. i.e. globalThis.x instead of x In-browser unless we\u2019re using modules, variables declared with var and global functions get added to the global object. We can use the global object to test for support of modern language features","title":"The global object"},{"location":"Advanced%20working%20with%20functions/#the-function-object","text":"Functions in JS are objects. So they have some usable properties of their own function f(){} Reflect.ownKeys(f) // [ 'length', 'name', 'arguments', 'caller', 'prototype' ] Reflect.ownKeys((a, b) => {}) // [ 'length', 'name' ] func. name : returns a read only name of the function function sayHi() {} sayHi.name // 'sayHi' let sayHi() = function(){} sayHi.name // 'sayHi' let user = { sayHi(){} } user.sayHi.name // 'sayHi' func. length : returns the number of arguments a function accepts function s( a, b, ...c){} s.length // 2 rest parameters are not counted custom properties we can add properties of our own to functions. // lets add a count property which stores the number of calls made to func function func(){ func.count++; console.log(func.count) } func.count = 0; func() // 1 func() // 2 func() // 3 Closures can sometimes be replaced with function properties // let's redo the makeCounter function with a custom property function makeCounter(){ function counter(){ return counter.count++; } counter.count = 0 ; reutrn counter; } let c = makeCounter(); c() // 0 c() // 1 c.count = 40; c() // 40 // In this case we can modify the counter","title":"The function object"},{"location":"Advanced%20working%20with%20functions/#named-function-expressions-nfe","text":"NFE is when we give names to the function on the right side of the function in our functional expressions. // normal functional expression let func = function() { } // NFE let func = function sayHi(){ } // NFE allows us to reference the function from within // the identifier sayHi isn't visible outside the function We use NFE when we want to reference the function from within the function. let sayHi = function func(ph){ if(ph) console.log(ph); else func(\"hello\"); } // We could have done let sayHi = function func(ph){ if(ph) console.log(ph); else sayHi(ph) } // but the above code will stop working if we change the value of sayHi let anotherFunc = sayHi; sayHi = null; anotherFunc(\"d\") // d anotherFunc() // Error sayHi is not a function // This happens because the identifier sayHi was taken from the outer L-Env // This can't be done with function declarations \ud83d\udce2 **Question** Write a function sum that would work like this: sum(1)(2) == 3; // 1 + 2 sum(1)(2)(3) == 6; // 1 + 2 + 3 sum(5)(-1)(2) == 6","title":"Named function expressions ( NFE )"},{"location":"Advanced%20working%20with%20functions/#new-function-syntax","text":"let func = new Function ([arg1, arg2, ...argN], functionBody); This syntax creates a function with arguments arg1 - argN with functionBody let func = new Function(functionBody) // a function without arguments Functions created with new Function() have an [[ Environment ]] referencing to the global Lex-Environment. This helps us to hide our local variables from them and to avoid running into problems when using minifiers. The arguments can also be given in a comma separated list. new Function(\"a\", \"b\", \"c\", \"alert(a)\" ); new Function(\"a,b\", \"c\", \"alert(a)\"); new Function(\"a,b,c\", \"alert(a)\" ) ; // all work the same","title":"new Function() syntax"},{"location":"Advanced%20working%20with%20functions/#scheduling-settimeout-setinterval","text":"These methods are not part of the JS specification. But most environments have an internal scheduler that provides these methods. setTimeout - causes a function or piece of code to run once after a period of time setInterval - causes a function to run regularly with the given interval // setTimeout( func, [delay] , [arg1], [arg2], [argn] ); delay in ms function sayHi(name){ console.log(`Hi ${name}` } let timerId = setTimeout(sayHi, 9000, \"Smith\"); // after 9 seconds => Hi Smith // a call to setTimeout returns a timerId we can use this to cancel it // setInterval(func, [delay], [arg1], [arg2], [argn] ); let timerId2 = setInterval(sayHi, 2000, \"Jack\" ); // Hi Jack will be displayed every 2 seconds canceling with clearTimeout and clearInterval clearTimeout( timerId ) clearInterval( timerId2 )","title":"Scheduling : setTimeout &amp; setInterval"},{"location":"Advanced%20working%20with%20functions/#recursive-settimeout","text":"There are two ways of running something regularly, using setInterval and with recursively calling setTimeout. let clock = setTimeout( function f(){ console.log(\"Tick Tok\"); setTimeout( f, 1000); }, 1000 ); This is a more flexible way because we can manipulate the delays. The recursive setTimout unlike setInterval guarantees the fixed delay ?? when a function is passed to setTimeout or setInterval, an internal reference to it is created and saved in the scheduler. This prevents the function from being garbage collected. But it also saved the outer lexical environment of the function, This might take much more memory than the function itself so when we don't need the scheduled function anymore it's better to cancel it. we can do that with clearTimeout and clearInterval","title":"Recursive setTimeout"},{"location":"Advanced%20working%20with%20functions/#decorators-and-forwarding-callapply","text":"Let's see how cool JS functions can be","title":"Decorators and forwarding, call/apply"},{"location":"Advanced%20working%20with%20functions/#transparent-caching","text":"If we want to cache(remember) the results for different arguments of a CPU intensive function we can create a wrapper function like so. function slow(x){ // slow calculations return x; } function cachingDecorator(func){ let cache = new Map(); return function(x){ if(cache.has(x)){ return cache.get(x); } let result = func(x); cache.add(x, result; return result; } } let slowFunc = cachingDecorator(slow); slow(1) // got computed and cached slow(1) // returned from cache This code will fail if we try to pass Object methods to the wrapper and access properties that belong to the \"this\" context of that object. let obj = { method(){ return 1; } slow(x){ // kicka$$ code return x + this.method(); } } let obj.slow = cachingDecorator(obj.slow); // this will fail because this.method() will be undefined To overcome this problem we can use function.call() to pass the context as well. func.call() allows us to explicitly pass \"this\" func.call( context, arg1, arg2, ... ); // syntax for .call() function greet(){ console.log(`Hello my name is ${this.name}`); } let jack = {name: \"Jack Taylor\"} let bob = {name: \"Bob Smith\"} greet.call(jack)// Hello my name is Jack Taylor greet.call(bob) // Hello my name is Bob Smith So we can simply fix our wrapper function by changing the assignment to let result = func.call(this, x); We can also pass the context to a function call using func. apply( context, args) where args is an array like , we can use this when we want to pass an array like containing the multiple arguments for the function we are about to call. let args = [1, \"2\", 3]; func.apply(context, args); // the same effect can be acheived with func.call(context, ...args); // But func.apply() can get optimized better by engines func.apply() doesn't accept iterables only array likes. \u26a0 **read about method borrowing** spy decorator \u2753 **Good Question** Create a decorator delay(f, ms) that delays each call of f by ms milliseconds. page# 383 function print(a) { console.log(a) } let f3000 = delay(print, 3000); f3000(\"hello\") // prints hello after 3 seconds Topics I have to look into again Function binding Currying and partials Arrow functions revisited Every thing from page 355 onward","title":"Transparent caching"},{"location":"Array%20methods%20cheat-sheet/","text":"Array methods cheat-sheet A cheat sheet of array methods: To add/remove elements: push(...items) \u2013 adds items to the end, pop() \u2013 extracts an item from the end, shift() \u2013 extracts an item from the beginning, unshift(...items) \u2013 adds items to the beginning. splice(pos, deleteCount, ...items) \u2013 at index pos delete deleteCount elements and insert items . slice(start, end) \u2013 creates a new array, copies elements from position start till end (not inclusive) into it. concat(...items) \u2013 returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken. To search among elements: indexOf/lastIndexOf(item, pos) \u2013 look for item starting from position pos , return the index or -1 if not found. includes(value) \u2013 returns true if the array has value , otherwise false . find/filter(func) \u2013 filter elements through the function, return first/all values that make it return true . findIndex is like find , but returns the index instead of a value. To iterate over elements: forEach(func) \u2013 calls func for every element, does not return anything. To transform the array: map(func) \u2013 creates a new array from results of calling func for every element. sort(func) \u2013 sorts the array in-place, then returns it. reverse() \u2013 reverses the array in-place, then returns it. split/join \u2013 convert a string to array and back. reduce(func, initial) \u2013 calculate a single value over the array by calling func for each element and passing an intermediate result between the calls. Additionally: Array.isArray(arr) checks arr for being an array. Please note that methods sort , reverse and splice modify the array itsel","title":"Array methods"},{"location":"Array%20methods%20cheat-sheet/#array-methods-cheat-sheet","text":"A cheat sheet of array methods: To add/remove elements: push(...items) \u2013 adds items to the end, pop() \u2013 extracts an item from the end, shift() \u2013 extracts an item from the beginning, unshift(...items) \u2013 adds items to the beginning. splice(pos, deleteCount, ...items) \u2013 at index pos delete deleteCount elements and insert items . slice(start, end) \u2013 creates a new array, copies elements from position start till end (not inclusive) into it. concat(...items) \u2013 returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken. To search among elements: indexOf/lastIndexOf(item, pos) \u2013 look for item starting from position pos , return the index or -1 if not found. includes(value) \u2013 returns true if the array has value , otherwise false . find/filter(func) \u2013 filter elements through the function, return first/all values that make it return true . findIndex is like find , but returns the index instead of a value. To iterate over elements: forEach(func) \u2013 calls func for every element, does not return anything. To transform the array: map(func) \u2013 creates a new array from results of calling func for every element. sort(func) \u2013 sorts the array in-place, then returns it. reverse() \u2013 reverses the array in-place, then returns it. split/join \u2013 convert a string to array and back. reduce(func, initial) \u2013 calculate a single value over the array by calling func for each element and passing an intermediate result between the calls. Additionally: Array.isArray(arr) checks arr for being an array. Please note that methods sort , reverse and splice modify the array itsel","title":"Array methods cheat-sheet"},{"location":"Code%20Quality/","text":"Code Quality We can write strings on multiple lines by adding \\ to the end of every line, this won\u2019t include the newline to the string. If we want to write multiple lines ( including the newline character) to a string we can include them inside backticks ( `` ) let str = \" hello world \\ how are you\"; console.log(str); // hello world how are you str = ` hello world`; // hello\\nworld Avoid nesting levels // instead of for( i=0; i<5; i++){ if(cond){ /*smth*/ } } // we can write for( i =0 ; i<5; i++){ if(!cond) continue; // smth } polyfills and babel ? transpiler","title":"Code Quality"},{"location":"Code%20Quality/#code-quality","text":"We can write strings on multiple lines by adding \\ to the end of every line, this won\u2019t include the newline to the string. If we want to write multiple lines ( including the newline character) to a string we can include them inside backticks ( `` ) let str = \" hello world \\ how are you\"; console.log(str); // hello world how are you str = ` hello world`; // hello\\nworld Avoid nesting levels // instead of for( i=0; i<5; i++){ if(cond){ /*smth*/ } } // we can write for( i =0 ; i<5; i++){ if(!cond) continue; // smth }","title":"Code Quality"},{"location":"Code%20Quality/#polyfills-and-babel","text":"transpiler","title":"polyfills and babel ?"},{"location":"Data%20Types/","text":"Data Types Four of the primitive types namely string, number, symbol, Boolean can behave like objects in that the dot operator can be used on them to get some of their \u201cproperties\u201d and methods. this is due to the use of \u201cwrapper objects\u201d. The four wrapper objects are String, Number, Boolean, Symbol. It\u2019s bad practice to call these constructors with the new keyword. let a = Number(\"123\"); typeof a // number let b = new Number(\"123\"); typeof b // object \u2753 Good question // what will happen ? let str = \"hello\"; str.test = 5; // (^) console.log(str.test); // (*) //Answer /* If we are not in strict mode, line (^) will create a String wrapper object and then * it creates the property test and gives it 5. then on line (*) it will return * undefined, since the previous wrapper object got removed. * If it's in strict mode in will return an error */ Numbers all numbers are stored in 64 bit format, also called double precision floating point numbers we can use \u2018e\u2019 to write numbers in short hand ( 7e4 = 70000, 23e-1 = 2.3 ) Hexadecimals - prefix 0x Binaries- prefix - 0b Octal- prefix -0o Number. toString(base): returns the string representation on the number, in the given base, if no base is given 10 is used as a default let num = 255; num.toString(2) // 11111111 num.toString(16) // ff // base 36- is the maximum 0-9 A-Z \u26a0\ufe0f two dots ( 34..toString()) // if we want to call methods directly on the number literals we can use 7..toString(2); (7).toString(2); // this is also possible /* If we were to use only one dot, it will imply that there is a decimal part after it, but the other dot resolves that issue, */ 6e3..toString(); // ERROR ! 6e3.toString() 0x3a2..toString(); // ERROR ! 0x3a2.toString() methods to modify numbers Math.floor(1.6) // 1 Math.ceil(1.2) // 2 Math.round(1.4) // 1 Math.trunc(2.12) // 2 removes the decimal part // to round a number to the n-th digit after the decimal let num = 1.2345; // to round this to the 2nd digit // 1 Math.floor(num * 100)/ 100 // 1.23 // 2 num.toFixed(2) // '1.23' string Imprecise calculations: From the 64 bits, used to represent numbers, 52 are used to store the digits, 11 are used to store the position of the decimal and 1 is used to store the sign. If a number is to big to be stored in this, it will overflow and resolve to infinity. 1e500; // infinity 0.1 + 0.2 // 0.30000000000000004 0.1.toFixed(25); // '0.1000000000000000055511151' Decimals that don\u2019t reduce to ( x/ 2), will be endless binary fractions, so there\u2019s no way to store them exactly, but JS rounds them to the nearest possible number, but these precision losses still exist. Infinity and NaN -Infinity and Infinity are special values which are smaller than or greater than any number. -NaN represents and error isNaN(arg) : - converts it\u2019s argument into a Number, and checks to see if it\u2019s NaN NaN == NaN // false // NaN can't equal any number or even it self Infinity == Infinity // true isFinite(arg) : - returns true if the arg, is not NaN, Infinity or -Infinity isFinite(\"123\") // true isFinite(\"str\") // false isFinite(1) // true // isFinite() can be used to check if a string holds a number isFinite(\"+3\") // true // !!! an empty or space only string resolves to 0 when casted to number isFinite(\" \") // true !!! Object.is( arg1, arg2) : - is the same as arg1 === arg2, except in these two cases it works with NaN Object.is(NaN, NaN) // true Values 0 and -0 are different. Object.is(0, -0) \u2192 false parseInt(str, base), and parseFloat(str) parseInt('45px') // 45 parseInt(\"3 Inch\") // 3 parseInt(\"4.7\") // 4 parseFloat(\"45.4em\") // 45.4 parseFloat(\"4.3.2\") // 4.3 // Fails parseInt(\"a45\") // if the first character is not a digit parseInt(\"abc\") // NaN // base given parseInt(\"ff\", 16) // 255 /* this is a great way to check if a number belongs to a base*/ isFinite(\"ii\", 16) // false isFinite(\"ii\", 36) // true Math.random() : - returns a random number \u2265 0 and < 1 Math.max(a, b, c, \u2026) and Math.min(a,b,c, \u2026) \u2753 Good Question /* why is 6.35.toFixed(1) == 6.3 */ // toFixed() works just like round() when rounding to a given precision // the problem happened because of the way 6.35 is represted 6.35.toFixed(20) // '6.34999999999999964473' // precision loss made 6.35 smaller // a better way to do it would be to Math.round(6.35 * 10) / 10 Strings The internal format for strings is UTF-16 and is not tied to page\u2019s encoding. Back ticks (``) allow for string interpolation, tagged templates and string that span multiple lines. \ud83d\udd25 Tagged strings [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals) Only quotes that are the same as the enclosing quotes will be escaped strings have a .length property Accessing characters: we can use [] operator or .charAt() let str = \"hello\"; str[0] // s str.charAt(0) // s str[100] // undefined str.charAt(100) // '' -> empty string \u26a1 for( .. of .. ) loop can be used on string because they are iterable let str = \"ola\"; for ( let c of str) ; String are immutable let str = \"selam\"; str[2] = 'd' // won't work, but it won't stop execution str // selam toUpperCase() and toLowerCase() searching for a substring str.indexOf(substr, index) let str = \"search for sub string\"; str.indexOf(\"search\") // 0 str.indexOf(\"s\") // 0 str.indexOf(\"s\", 1) // 11 // if it doesn't find it str.indexOf(\"max\") // -1 str.indexOf(\"s\", 100) // -1 \u2753 Good Question /* count occurances of a substring in a string */ let str = \"JavaScript is a very cool language\"; let target = \"a\"; let cnt = 0, pos = 0; while(true){ if(str.indexOf(target, pos++) != -1) {cnt++} else {break} str.lastIndexOf(substr, index) :- searches starting from the end of string to the start str.includes(substr, index) : - returns true if str includes substr str.startsWith(prefix) : - returns true if str starts with prefix str.endsWith(suffix) : - Getting a substring str.slice(start, end) :- returns a in between start index and end index, including the start and excluding the end let str = \"string\" str.slice(1, 3) // tr // if the end is not given it's defaulted to legth of the string str.slice(2) // ring str.slice() // string // negative values are also allowed str.slice(-4, -1) // rin str.substring(start, [ end ]) :- is the same as slice, but allows the start to be greater than end, and it doesn\u2019t support negative arguments, it will just treat them as 0. str.substr(start, [ length ]) :- returns part of the string starting from the start upto the given length. The start can be negative let str = \"string\" str.substring(2, 4) // ri str.substring(4, 2) // ri str.substring(-2 ) // string // substr str.substr(2, 3) // rin str.substr(3) // ing str.substr(-4, 2) // ri string comparison methods codePointAt(index) and String.fromCodePoint(point) \"Z\".codePointAt(0) // 90 returns the code for the character at position 0 \"a\".codePointAt(0) // 97 String.fromCodePoint(90) // Z returns the character at the given code point String.fromCodePoint(97) // a In-order to do correct string comparisons in different languages, we can use the localeCompare(str2) method from the Intl.JS library. let str1 = \"apple\" let str2 = \"ball\" str1.localeCompare(str2) // -1 because it's less str2.localeCompare(str1) // 1 str1.localeCompare(str1) // 0 \ud83d\udcdd **Surrogate pairs** - All frequently used Unicode characters have 2byte codes, but some have two pairs of those. these characters have a length of two. \ud83d\udcdd **Diacritical marks and normalization -** some letters have marks above / below them we can do this by adding the marks Unicode after our symbols. eg. \u2018S\\u0307\u2019 is \u1e60 and 'S\\u0307\\u0323\u2019 is \u1e68. these bring an interesting problem in that similar looking characters will can get represented by different codes, to overcome this we can use the **normalize()** method. it will bring these characters to a common normal form Arrays Arrays are objects that can store different types of data, and they can grow dynamically, the elements of an array are stored in contiguous memory area. let A = new Array(); let B = [ \"jhon\", 4 , 8.3, function() {console.log(\"hello\")} ] B.length // 4 B[4] = \"abc\"; B.length // 5 B[3]() // hello In JS arrays support both stacks ( LIFO ) and queues ( FIFO ), this is also called deque Methods .push() and .pop(): work with the end of an array, push returns the size of the new array Methods .shift() and . unshift() shift() works just like pop() but it operates on the first element unshift() works just like push() but to the beginning of the array, unshift can take multiple arguments, it returns the size of the new array Methods push and pop are much faster than shift and unshift, because they don\u2019t have to reorder the elements after they are done. \ud83d\udcdd Arrays are optimized to work fast, but if we start treating them like objects we will lose the benefits of the optimizations. The ways we can misuse Arrays are ~ By adding non-numeric properties ~ Creating gaps in between the indexes ar[0] ar[1000] nothing in between ~ Filling the array in the reverse order Looping through arrays: let arr = [ \"name\", \"age\", \"school\" ] // using a traditional for loop for(let i =0; i < arr.length ; i ++ ) arr[ i] ; // using for .. of loop for( let val of arr) var // not recommended ! using for ... in loops // 10 - 100 times slower than for ... of for( let val in arr) arr[val] \u2622\ufe0f The **length** property : - Automatically updates when the array is modified. length is not the number of values in the array but the largest numeric index + 1. **The length property is writable:** We can change the value of length. if we increase it nothing special will happen, but if we decrease it, the array will be truncated // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! let arr = [ 1, 2,3 4,5 ] arr.length = 2; arr // [ 1, 2 ] arr.length = 4; arr // [ 1, 2, undefined, undefined] // therefore the simplest way to clear an array is arr.length = 0; \u26a0\ufe0f Careful when using new Array(). If we call the constructor with one numeric argument, it will take create an array with that size let a = new Array(3); a[1] // undefined a.length // 3 Multidimensional arrays let a = [ [ 1, 2, 3], [ 4, 5, 6], [ 7, 8, 9] ]; a[1][2] // 6 Arrays\u2019 toString() : returns a comma separated list of the elements \u2699 array.splice( from [ , count, elemt1, elment2, \u2026] ) : returns the array of removed elements. Starting from \u2018from\u2019 remove \u2018count\u2019 elements and replace them with elemts let arr1 = [1, 2, 3, 4, 5, 6] arr1.splice( 1, 2 ) // => [ 4, 5, 6] arr1 // [ 1, 2, 3 ] arr1 = [1, 2, 3, 4, 5, 6] arr1.splice(0, 2, \"hello\" ,\"world\"); // [ 1, 2 ] arr1 // [ \"hello\", \"world\", 3, 4, 5, 6 ] // we can use splice to insert with out deleting by setting count to 0 arr1.splice( 1, 0, \"great\" ) // [] arr1 // [\"hello\", \"great\", \"world\", 3, 4, 5, 6 ] // negative indexes are allowed arr1.splice( -4, 4) // [ 3, 4, 5, 6 ] arr1 // [ \"hello\", \"great\", \"world\" ] \u2699 Method **slice( start , end)**, works on arrays and strings and returns a subarray from index start to end or a substring if it\u2019s called on a string let str = \"hello\" let arr = ['h', 'e', 'l', 'l', 'o' ] str.slice(1, 4) // 'ell' arr.slice(1, 4) // [ 'e', 'l', 'l' ] str.slice(2) // 'llo' \u2699 Method array.concat( arg1, arg2, \u2026) : returns array concatenated with the arguments. If the argument is has a Symbol.isConcatSpreadable it will get spreaded and concatenated to array. if not it will be appended to the end of array as it is let arr = [ 1,2,3,4 ] arr.concat(\"yee\", \"haa\") // [ 1,2,3,4,\"yee\", \"haa\" ] arr // [ 1,2,3,4 ] concat doesn't alter arr let arr2 = [ \"ping\", \"pong\" ] arr.concat(\"I\", \"love\", arr2 ) // [ 1,2,3,4,\"I\", \"Love\", \"ping\", \"pong\" ] let obj = { 0 : 'yee', 1 : 'ha' , [Symbol.isConcatSpreadable] : true, } arr.concat(obj) // [ 1,2,3,4,'yee', 'ha'] \u2699 Method array.forEach(func) : allows you to run a function on each element of the array. functions called inside forEach get passed the arguments ( item, index, array ) > let arr = [ 1,2,3 ] > arr.forEach(console.log()); 1 0 [ 1, 2, 3, 4, 5, 6 ] 2 1 [ 1, 2, 3, 4, 5, 6 ] 3 2 [ 1, 2, 3, 4, 5, 6 ] > > let func = (item, index, array) => console.log(`item : ${item}, index : ${index}, array: ${array}`) > arr.forEach(func); item: 1, index: 0, array: 1,2,3,4,,5,6 item: 2, index: 1, array: 1,2,3,4,,5,6 item: 3, index: 2, array: 1,2,3,4,,5,6 Searching in an array \u2699 methods arr.**indexOf(item, from),** arr.**lastIndexOf(item, from),** arr.**includes(item, from)** do the same things as their string counter-parts, they use the === comparison. **** // one notable difference is const arr = [NaN]; arr.indexOf(NaN) // -1 arr.includes(NaN) // true \u2699 method arr.**find( function )** :- if function returns true, iteration is stopped and the item is returned, if false undefined is returned. const arr = [ { id: 1, age: 34 }, { id: 2, age: 23 }, { id: 3, age: 34 }, ] // to find element with id 2 arr.find( (item, index, array) => item.id == 2 ); // { id: 2, age: 23 } // to find element with age 23 arr.find( item => item.age == 23 ) // { id: 2, age: 23 } \u2699 method arr.**findIndex( function )** :- is the same as find() but, it returns the index if its found and -1 if not > let arr2 = [ 1,2,3,4,5 ] > arr2.findIndex( item => item == 3 ); 2 \u2699 method **arr.filter( function ) :-** is also the same as find() but it returns an array of objects that fulfill the condition. > arr.filter( item => item.age == 34 ); [ { id: 1, age: 34 }, { id: 3, age: 34 } ] Transforming arrays \u2699 method arr.map(function) : returns a new array of the results of the function > let arr = [ 1,2,3,4,5 ] > arr.map(item => item + 1); [ 2,3,4,5,6 ] > [ \"a\", \"ab\", \"abc\" ].map( item => item.length ) [ 1,2,3 ] \u2699 method arr.**sort(func)** :- sorts arr based on func, if func is not given it will treat it like a string > [ 13, 5, 1].sort(); [ 1, 13, 5 ] // because it tried to sort it like a string /* if we want it to sort based on a function, we need to supply a function of two * arguments */ > function comp( a, b ) { if( a > b ) return 1; if( a < b ) return -1; if( a === b) return 0; } > [ 13, 5, 1].sort(comp); [ 1, 5, 13 ] /* compare functions are only required to return a positive number to say greate and a * negative number to say less, so we can do this instead */ > [ 13, 5, 1].sort( (a, b) => a - b ) [ 1, 5, 13] \u2699 method **arr.reverse()** :- reverses the array and returns it. it will change the array let ar = [ 1, 2, 3, 4 ] ar.reverse() // [ 4, 3, 2, 1 ] ar // [ 4, 3, 2, 1 ] split and join \u2699 method string.split(delimiter, limit) : splits a string into an array based on the delimiter \u2699 method arr.join(delimiter) : does the reverse of split() let str = \"hello , world\"; str.split() // [ \"hello , world\" ] str.split(\"\") // [ 'h', 'e', 'l', 'l', 'o', ' ' , ',', 'w' ...] arr = str.split(\",\") // [ \"hello \", \" world\" ] arr.join(\":\") // \"hello : world\" str.split(\",\", 1) // [ \"hello\" ] reduce and reduceRight \u2699 method arr.reduce( func( previous, item, index, array) ) :- reduces the array into a single value based on the function passed let arr = [ 'a', 'b', 'c', 'd' ] arr.reduce ( (prev, item) => prev + \",\" + item ); // 'a,b,c,d' let arr2 = [ 1, 2, 3, 4 ] arr2.reduce( (prev, current) => prev + current, 0 ); // 10 /* we can specify an initial prev after the comma, we gave it 0 above reduceRight() : does the same thing but does it from the right Array.isArray(arr) : returns true if arr is an array all array methods except sort() support an additional thisArg Array methods cheat-sheet Iterables Iterables are objects that can be used by a for \u2026 of loop Symbol.iterator To make our on iterable objects we have to add a method called Symbol.iterator, which returns an iterator object which includes a method called next which returns an object of the format { done: boolean, value: next_value }. let range = { from: 1, to: 5, } range[Symbol.iterator] = function(){ return{ this.current = this.from, this.last = this.to, next(){ if(this.current <= this.last) return { done: false, value: this.current++ } else return {done: true} } } } for(i of range) console.log(i) // 1, 2, 3, 4, 5 The object we want to iterate over can be used as the iterator itself to make the code simpler let range = { from: 5, to: 10, [Symbol.iterator](){ this.current = this.from; return this } next(){ if(this.current <= this.to) return { done: false, value: this.current++} else return { done: true } } } for( i of range ) // 5 6 7 8 9 10 /* But this implementation won't allow us to run simultaneously because they will * share the same iteration state */ Calling an iterator explicitly We can iterate oven an iterable manually let str = \"hello\" let iterator = str[Symbol.iterator](); while(true){ let result = iterator.next(); if(result.done) break; console.log(result.value) } Iterables and array-likes Iterables are objects that implement the Symbol.iterator method and Array likes are those that have indexes and a length property. Array.from(obj, [mappingFunc, thisArg]) creates arrays from iterables or array-likes let a = Array.from(range) // the previous iterable a // [ 5,6,7,8,9,10 ] // we can pass a mapping function to be applied let b = Array.from(range, num => num*2 ) b // [10, 12, 14, 16, 18, 20 ] // to get array of characters from a string let str = \"hello\" let c = Array.from(str) // this approach unlike split, works fine with surrogate pairs Maps Maps are like objects in that they are keyed collections of data items, but unlike objects maps allow keys of any types. \ud83d\udea8 Main methods - **new Map()** - create a map - **map.set(key, value)** - stores the value by key - **map.get(key)** - gets value by key - **map.has(key)** - returns true if key exists - **map.delete(key)** - deletes value by key - **map.clear()** - clears the map - **map.size** - returns the size of the map let a = new Map() a.set(1, \"a\") a.set('1', \"b\") a.set(true, \"c\") a.get(1) // 'a' a.get('1') // 'b' a.get(true) // 'c' a.has(false) // false Every map.set() return the map itself so we can chain our sets a.set(1, \"a\").set('1', \"b\").set(true, \"c\") Maps from objects we can pass an array or other iterables with key value pairs when creating a map let a = new Map([ 1, \"a\"], [ \"2\", \"b\"], [ false, 4 ]); The method Object.entries(obj) creates a key value pair array from an object let obj = { name: \"dani\", age: 56, sex: \"male\" } let ent = Object.entries(obj); ent // [ [\"name\", \"dani\"], [\"age\", 56], [\"sex\", \"male\"] ] let m = new Map(ent); Iteration over maps maps.keys() - returns an iterable for keys maps.values() - returns an iterable for values maps.entries() - returns an iterable for entries, it\u2019s used by default in a for\u2026of loop > let m = new Map(Object.entries({ name: \"jim\", age: 45, height: 174 }) ); > for( i of m.keys() ) console.log(i) name age height > for( i of m.values() ) console.log(i) jim 45 174 > for( i of m ) console.log(i) // same as m.entries() [ \"name\", \"jim\" ] [ \"age\", 45 ] [ \"height\", 175 ] Set A set is a collection of values where a value can only occur once. \ud83d\udea8 Methods **new Set( iterable )** - creates a set, if an iterable is given in copies it in **set.add( value )** - adds a value to a set **set.delete( value )** - removes a value from a set **set.has( value )** - checks to see if the set has that value **set.clear()** - clears the set **set.size** - elements count iterating over a set we can iterate over the set using a for.. of. loop of a forEach() let set = new Set( [ 1, 3, 5, 6 ] ) for( i of set ) console.log(i) // 1, 3, 5, 6 set.forEach( (value, valueAgain, map) => console.log(value) ) // 1, 3, 5, 6 /* The callback function called in forEach passes three arguments of which 2 are the * values, this is done for compatibility with maps. In this spirit sets also have * the methods to return iterables, set.keys(), set.values(), set.entries() * keys() and values() both return the values, and entries returns [ value, value ]*/ WeakMap and WeakSet The garbage collector doesn\u2019t free up objects if they are referenced in arrays, maps or sets. let obj = { str: \"I'll live forever\" } let arr = new Array(obj); obj = null; arr // [ { str: \"I'll live forever\" } ] WeakMap and WeakSet don\u2019t prevent the garbage collector from doing it\u2019s job. WeakMaps and WeakSets WeakMaps can\u2019t have primitive values as their keys. WeakMaps don\u2019t support iteration. \ud83d\udea8 WeakMap methods **new WeakMap() -** creates a weak map **weakmap.get( key ) -** gets a value **weakmap.set( key, value ) weakmap.has( key ) weakmap.delete( key )** The garbage collector performs clean up at a time of it\u2019s choosing, so the size of weakmap can\u2019t be known, that\u2019s why the other methods can\u2019t operate on weakmaps. Weaksets are analogous to sets Object.keys(obj) .values(obj) and .entries(obj) Objects just like maps and sets also support these methods, but unlike maps and sets they return arrays and not iterables, let obj = { name: \"candy\", sweet: true } Object.keys(obj) // [ \"name\", \"sweet\" ] Object.values(obj) // [\"candy\", true ] These methods also ignore symbol properties, but we can use methods Object.getOwnPropertySymbols(obj) - to return only the symbolic keys and method Reflect.ownKeys(obj) - to get all the keys Object.fromEntries( [] ) - creates objects from entries, or maps let arr = [ [\"name\", \"candy\"], [\"sweet\",true] ] Object.fromEntries(arr) // { name: \"candy\", sweet: true } // also works on maps Destructuring assignment destructuring assignment is a special syntax that allows us to unpack arrays or objects in to variables. Array destructuring // Array destructuring let [ first, last ] = [ \"Barack\", \"Obama\" ] // we could also do this let [ first, last ] = \"Barack Obama\".split(\" \"); // we can skip over unwanted elements with commas We can use any iterable on the right side let map = new Map(); map.set(\"name\",\"jhon\").set(\"age\",8).set(\"height\", 174); let [ first, , last ] = map first // \"name\", \"jhon\" last // \"height\", 174 // or string [a, b, c] = \"1234\"; a // 1 b // 2 We can also store the rest of the elements of the array using \u2026var, with var being an array of everything else let arr = \"hello world this is javascript speaking\".split(\" \"); let [ a, b, ...c] = arr a // hello b // world c[0] // this c[1] // is When there are fewer elements in the array than the variables, the remaining variables are passed undefined. We can define default values for the variables if that happens let [ a = \"empty\", b = \"empty\"] = [\"hello\"] a // hello b // empty // the default values can also be calls to functions Object destructuring let obj = { name: \"Andy\", sex: \"male\", age: 13, } let { age, sex, name } = obj; // order doesn't matter If we want to assign the properties to variables with a different name we can use a colon let { name: n, sex, age: years } = obj For potentially missing values we can specify a default using = let { name, country = \"UK\", age } = obj name // \"Andy\" country // \"UK\" // default values can also be calls to functions If we want to combine both the equality and colon , we can do so as such let { name: n = \"Jhon\" } = obj If we want the rest of the objects properties we can use \u2026var, where var will be an object with the rest of the properties let { name, ...rest } = obj name // \"Andy\" rest // { sex: \"male\", age:13 } rest.age // 13 Nested destructuring If an object or array contains other objects and arrays we can use nested destructuring to extract the deeper portions. let box = { size: { width: 3, height: 5, depth: 2, }, colors: [ \"red\", \"green\" ], } let { size: { width, height, }, colors: [ color1, color2 ], } = box; width // 3 height // 5 color1 // red size // undefined colors // undefined Smart function parameters When we have many parameters of which several are optional, it can become hard to remember their position, we can work around this problem by using object destructuring. we can pass them objects and the use the function to destructurize them into variables. let movie = { title: \"Avengers\", genre: [ \"action\", \"drama\" ], }; function showMovie ( {title = \"no title\", duration = 2.00, genre} ){ console.log(` ${title} , ${duration} , ${genre} `); } showMovie(movie); // Avengers, 2.00, action, drama // we can also specify default values and new names function showMovie( { title: name = \"no title\", duration = 2.00, genre: [ g1 ]}) /* if we want all defaults we can't just do showMovie() but showMovie({}), to work * around this problem we can specify {} as a default for the whole parameter */ function showMovie( {title = \"no title\", genre: [g1, g2]} = {} ) {} // doing ={} will make it possible to just call showMovie() Date Creation new Date() // without arguments creates a date object for the current date and time. new Date( milliseconds ) // creates a date object with the time equal to the number of milliseconds past since the Jan 1- 1970. The number of milliseconds past since since 1970 is called a timestamp new Date( date string ) \u2014 the date string get parsed with the Date.parse algorithm new Date( year, month, day, hours, minutes, seconds, milliseconds ) - The first two arguments are obligatory . Year must have four digits. month count starts from 0 - 11. default of day is 1. If the rest are missing they are assumed to be 0. new Date() // 2022-07-12T07:19:10.943Z -- current time new Date(0) // 1970-01-01T00:00:00.000Z new Date(\"2020-4-8\") // 2020-04-07T21:00:00.000Z new Date(1994, 4) // 1994-04-30T21:00:00.000Z new Date(2002, 9, 11, 4) // 2002-10-11T01:00:00.000Z Access date components getFullYear() - get the year ( 4 digit ) getMonth() - getDate() - getHours(), getMinutes(), getSeconds(), getMilliseconds() getDay() // 0-6 , where 0 is sunday // These methods also have UTC counterparts like getUTCHours(), getUTCMinutes() etc. getTime() // returns the date\u2019s timestamp since Jan1/ 1970 UTC+0. has no UTC variant getTimezoneOffset() // returns the difference b/n local time zone and UTC in minutes Modify date components setFullYear( year [, month, date ] ) setMonth( month [, date] ) setDate( date ) setHours( hours [, minutes, seconds, millis ] ) setMinutes( minutes [, seconds, millis ] ) setSeconds( seconds [, millis ] ) setMilliseconds( millis ) setTime ( timestamp ) Autocorrection let a = new Date(\"2002\\1\\30\"); a.setDate(a.getDate() + 4) a // 2002-02-02T21:00:00.000Z // we can use this technique to get the date after some time has elapsed a.setMinutes( a.getMinutes() + 40 ) // date after 40 minutes a.setSeconds( a.getSeconds() + 4900 ) // date after 4900 seconds We can also set numbers \u2264 0 let a = new Date(\"2002/2/23\"); a.setDate(0) // last day of previous month a.setDate(-3) // before 3 days and before 3 month for some reason Casting to numbers when dates get cast into numbers they return their timestamps. let a = new Date(2002, 1, 23); +a // 1014411600000 Date.parse() The string format should be: YYYY-MM-DDTHH:mm:ss.sssZ , where: YYYY-MM-DD \u2013 is the date: year-month-day. The character \"T\" is used as the delimiter. HH:mm:ss.sss \u2013 is the time: hours, minutes, seconds and milliseconds. The optional 'Z' part denotes the time zone in the format +-hh:mm . A single letter Z that would mean UTC+0. JSON - ( JavaScript Object Notation ) Is a general format to represent Objects and values. It\u2019s a data only cross language specification. JSON.stringify() \u2014 converts objects in to strings, the resulting strings are called JSON-encoded or serialized or stringified or marshalled object. JSON.parse() \u2014 converts JSON into objects let obj = { name: \"my object\", description: 'an object', } let a = JSON.stringify(obj); a // '{\"name\":\"my object\",\"description\":\"an object\"}' typeof a // 'string' let b = JSON.parse(a); b // { name: 'my object', description: 'an object' } JSON-encoded objects - use only double quotes for strings, so \u2018an object\u2019 becomes \u201can object\u201d. They also double quote property names so name becomes \u201cname\u201d. JSON methods can natively be applied to objects, arrays, primitives(strings, numbers, booleans, and null) JSON.strigify() - skips methods, symbol properties, and properties that store undefined, since it\u2019s data only let obj = { method() { /* do smth */ }, prop1: undefined, [Symbol(\"id\")]: '01', } JSON.stringify(obj) // '{}' stringify() \u2014 supports nested objects, as long as there\u2019s no circular references. let room = { number: 23 }; let meetup = { title: \"Conference\", participants: [\"john\", \"ann\"] }; meetup.place = room; // meetup references room room.occupiedBy = meetup; // room references meetup JSON.stringify(meetup); // Error: Converting circular structure to JSON JSON.stringify( value [, replacer, space] ) where replacer is an array of properties to encode or a mapping function(key, value) and space is the amount of space to use for formatting. replacer passing an array let obj = { name: \"candy\", age: 50, other: [{height: 5.6}, {weight: 140}], sex: \"f\", } let s = JSON.stringify(obj, [\"name\", \"age\", \"other\", \"height\"]) s // '{\"name\": \"candy\", \"age\": 50, \"other\": [{\"height\": 5.6}, {}]}' // properties \"sex\" and \"weight\" are not encoded since they are not mentioned /* we can safely skip properties that cause circular references by not adding them * to the replacer array */ passing a function // let's make candy 12 years old let s = JSON.stringify(obj, (key, value) => { return key == \"age\" ? 12 : value; }); s // '{\"name\": \"candy\", \"age\": 12, \"other\": [{\"height\": 5.6}, {}]}' The first call passes a key value pair with the key(\u201d\u201d) and value of the object itself { \u201c\u201d: obj } spaces used to specify the number of spaces used for indentation, used for logging and output let obj = { continent: \"Africa\", countries: [ \"Ethiopia\", \"Mali\" ] } /* { \"continent\": \"Africa\", \"countries\": [ \"Ethiopia\", \"Mali\", ] } */ Custom toJSON conversion Just like toString() we can add a toJSON() method to our objects. JSON.stringify() calls this method if it exists let room = { number: 1, toJSON() { return this.number; } } JSON.stringify(room) // 1 JSON.parse(str [, reviver]) we can customize the parsing of json to objects by passing a reviving function. // consider the case let obj = { name: \"Elias\", dob: new Date() } let json = JSON.stringify(obj) json // '{\"name\":\"Elias\",\"dob\":\"2022-07-13T08:24:52.846Z\"}' let obj2 = JSON.parse(json) obj2 // { name: 'Elias', dob: '2022-07-13T08:24:52.846Z' } ! dob became a string let obj3 = JSON.parse(json, (key, value) => { return key == \"dob\" ? new Date(value) : value; }); obj3 // '{\"name\":\"Elias\",\"dob\":\"2022-07-13T08:24:52.846Z\"}'","title":"Data Types"},{"location":"Data%20Types/#data-types","text":"Four of the primitive types namely string, number, symbol, Boolean can behave like objects in that the dot operator can be used on them to get some of their \u201cproperties\u201d and methods. this is due to the use of \u201cwrapper objects\u201d. The four wrapper objects are String, Number, Boolean, Symbol. It\u2019s bad practice to call these constructors with the new keyword. let a = Number(\"123\"); typeof a // number let b = new Number(\"123\"); typeof b // object \u2753 Good question // what will happen ? let str = \"hello\"; str.test = 5; // (^) console.log(str.test); // (*) //Answer /* If we are not in strict mode, line (^) will create a String wrapper object and then * it creates the property test and gives it 5. then on line (*) it will return * undefined, since the previous wrapper object got removed. * If it's in strict mode in will return an error */","title":"Data Types"},{"location":"Data%20Types/#numbers","text":"all numbers are stored in 64 bit format, also called double precision floating point numbers we can use \u2018e\u2019 to write numbers in short hand ( 7e4 = 70000, 23e-1 = 2.3 ) Hexadecimals - prefix 0x Binaries- prefix - 0b Octal- prefix -0o Number. toString(base): returns the string representation on the number, in the given base, if no base is given 10 is used as a default let num = 255; num.toString(2) // 11111111 num.toString(16) // ff // base 36- is the maximum 0-9 A-Z \u26a0\ufe0f two dots ( 34..toString()) // if we want to call methods directly on the number literals we can use 7..toString(2); (7).toString(2); // this is also possible /* If we were to use only one dot, it will imply that there is a decimal part after it, but the other dot resolves that issue, */ 6e3..toString(); // ERROR ! 6e3.toString() 0x3a2..toString(); // ERROR ! 0x3a2.toString() methods to modify numbers Math.floor(1.6) // 1 Math.ceil(1.2) // 2 Math.round(1.4) // 1 Math.trunc(2.12) // 2 removes the decimal part // to round a number to the n-th digit after the decimal let num = 1.2345; // to round this to the 2nd digit // 1 Math.floor(num * 100)/ 100 // 1.23 // 2 num.toFixed(2) // '1.23' string Imprecise calculations: From the 64 bits, used to represent numbers, 52 are used to store the digits, 11 are used to store the position of the decimal and 1 is used to store the sign. If a number is to big to be stored in this, it will overflow and resolve to infinity. 1e500; // infinity 0.1 + 0.2 // 0.30000000000000004 0.1.toFixed(25); // '0.1000000000000000055511151' Decimals that don\u2019t reduce to ( x/ 2), will be endless binary fractions, so there\u2019s no way to store them exactly, but JS rounds them to the nearest possible number, but these precision losses still exist. Infinity and NaN -Infinity and Infinity are special values which are smaller than or greater than any number. -NaN represents and error isNaN(arg) : - converts it\u2019s argument into a Number, and checks to see if it\u2019s NaN NaN == NaN // false // NaN can't equal any number or even it self Infinity == Infinity // true isFinite(arg) : - returns true if the arg, is not NaN, Infinity or -Infinity isFinite(\"123\") // true isFinite(\"str\") // false isFinite(1) // true // isFinite() can be used to check if a string holds a number isFinite(\"+3\") // true // !!! an empty or space only string resolves to 0 when casted to number isFinite(\" \") // true !!! Object.is( arg1, arg2) : - is the same as arg1 === arg2, except in these two cases it works with NaN Object.is(NaN, NaN) // true Values 0 and -0 are different. Object.is(0, -0) \u2192 false parseInt(str, base), and parseFloat(str) parseInt('45px') // 45 parseInt(\"3 Inch\") // 3 parseInt(\"4.7\") // 4 parseFloat(\"45.4em\") // 45.4 parseFloat(\"4.3.2\") // 4.3 // Fails parseInt(\"a45\") // if the first character is not a digit parseInt(\"abc\") // NaN // base given parseInt(\"ff\", 16) // 255 /* this is a great way to check if a number belongs to a base*/ isFinite(\"ii\", 16) // false isFinite(\"ii\", 36) // true Math.random() : - returns a random number \u2265 0 and < 1 Math.max(a, b, c, \u2026) and Math.min(a,b,c, \u2026) \u2753 Good Question /* why is 6.35.toFixed(1) == 6.3 */ // toFixed() works just like round() when rounding to a given precision // the problem happened because of the way 6.35 is represted 6.35.toFixed(20) // '6.34999999999999964473' // precision loss made 6.35 smaller // a better way to do it would be to Math.round(6.35 * 10) / 10","title":"Numbers"},{"location":"Data%20Types/#strings","text":"The internal format for strings is UTF-16 and is not tied to page\u2019s encoding. Back ticks (``) allow for string interpolation, tagged templates and string that span multiple lines. \ud83d\udd25 Tagged strings [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals) Only quotes that are the same as the enclosing quotes will be escaped strings have a .length property Accessing characters: we can use [] operator or .charAt() let str = \"hello\"; str[0] // s str.charAt(0) // s str[100] // undefined str.charAt(100) // '' -> empty string \u26a1 for( .. of .. ) loop can be used on string because they are iterable let str = \"ola\"; for ( let c of str) ; String are immutable let str = \"selam\"; str[2] = 'd' // won't work, but it won't stop execution str // selam toUpperCase() and toLowerCase()","title":"Strings"},{"location":"Data%20Types/#searching-for-a-substring","text":"str.indexOf(substr, index) let str = \"search for sub string\"; str.indexOf(\"search\") // 0 str.indexOf(\"s\") // 0 str.indexOf(\"s\", 1) // 11 // if it doesn't find it str.indexOf(\"max\") // -1 str.indexOf(\"s\", 100) // -1 \u2753 Good Question /* count occurances of a substring in a string */ let str = \"JavaScript is a very cool language\"; let target = \"a\"; let cnt = 0, pos = 0; while(true){ if(str.indexOf(target, pos++) != -1) {cnt++} else {break} str.lastIndexOf(substr, index) :- searches starting from the end of string to the start str.includes(substr, index) : - returns true if str includes substr str.startsWith(prefix) : - returns true if str starts with prefix str.endsWith(suffix) : -","title":"searching for a substring"},{"location":"Data%20Types/#getting-a-substring","text":"str.slice(start, end) :- returns a in between start index and end index, including the start and excluding the end let str = \"string\" str.slice(1, 3) // tr // if the end is not given it's defaulted to legth of the string str.slice(2) // ring str.slice() // string // negative values are also allowed str.slice(-4, -1) // rin str.substring(start, [ end ]) :- is the same as slice, but allows the start to be greater than end, and it doesn\u2019t support negative arguments, it will just treat them as 0. str.substr(start, [ length ]) :- returns part of the string starting from the start upto the given length. The start can be negative let str = \"string\" str.substring(2, 4) // ri str.substring(4, 2) // ri str.substring(-2 ) // string // substr str.substr(2, 3) // rin str.substr(3) // ing str.substr(-4, 2) // ri","title":"Getting a substring"},{"location":"Data%20Types/#string-comparison","text":"methods codePointAt(index) and String.fromCodePoint(point) \"Z\".codePointAt(0) // 90 returns the code for the character at position 0 \"a\".codePointAt(0) // 97 String.fromCodePoint(90) // Z returns the character at the given code point String.fromCodePoint(97) // a In-order to do correct string comparisons in different languages, we can use the localeCompare(str2) method from the Intl.JS library. let str1 = \"apple\" let str2 = \"ball\" str1.localeCompare(str2) // -1 because it's less str2.localeCompare(str1) // 1 str1.localeCompare(str1) // 0 \ud83d\udcdd **Surrogate pairs** - All frequently used Unicode characters have 2byte codes, but some have two pairs of those. these characters have a length of two. \ud83d\udcdd **Diacritical marks and normalization -** some letters have marks above / below them we can do this by adding the marks Unicode after our symbols. eg. \u2018S\\u0307\u2019 is \u1e60 and 'S\\u0307\\u0323\u2019 is \u1e68. these bring an interesting problem in that similar looking characters will can get represented by different codes, to overcome this we can use the **normalize()** method. it will bring these characters to a common normal form","title":"string comparison"},{"location":"Data%20Types/#arrays","text":"Arrays are objects that can store different types of data, and they can grow dynamically, the elements of an array are stored in contiguous memory area. let A = new Array(); let B = [ \"jhon\", 4 , 8.3, function() {console.log(\"hello\")} ] B.length // 4 B[4] = \"abc\"; B.length // 5 B[3]() // hello In JS arrays support both stacks ( LIFO ) and queues ( FIFO ), this is also called deque Methods .push() and .pop(): work with the end of an array, push returns the size of the new array Methods .shift() and . unshift() shift() works just like pop() but it operates on the first element unshift() works just like push() but to the beginning of the array, unshift can take multiple arguments, it returns the size of the new array Methods push and pop are much faster than shift and unshift, because they don\u2019t have to reorder the elements after they are done. \ud83d\udcdd Arrays are optimized to work fast, but if we start treating them like objects we will lose the benefits of the optimizations. The ways we can misuse Arrays are ~ By adding non-numeric properties ~ Creating gaps in between the indexes ar[0] ar[1000] nothing in between ~ Filling the array in the reverse order","title":"Arrays"},{"location":"Data%20Types/#looping-through-arrays","text":"let arr = [ \"name\", \"age\", \"school\" ] // using a traditional for loop for(let i =0; i < arr.length ; i ++ ) arr[ i] ; // using for .. of loop for( let val of arr) var // not recommended ! using for ... in loops // 10 - 100 times slower than for ... of for( let val in arr) arr[val] \u2622\ufe0f The **length** property : - Automatically updates when the array is modified. length is not the number of values in the array but the largest numeric index + 1. **The length property is writable:** We can change the value of length. if we increase it nothing special will happen, but if we decrease it, the array will be truncated // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! let arr = [ 1, 2,3 4,5 ] arr.length = 2; arr // [ 1, 2 ] arr.length = 4; arr // [ 1, 2, undefined, undefined] // therefore the simplest way to clear an array is arr.length = 0; \u26a0\ufe0f Careful when using new Array(). If we call the constructor with one numeric argument, it will take create an array with that size let a = new Array(3); a[1] // undefined a.length // 3 Multidimensional arrays let a = [ [ 1, 2, 3], [ 4, 5, 6], [ 7, 8, 9] ]; a[1][2] // 6 Arrays\u2019 toString() : returns a comma separated list of the elements \u2699 array.splice( from [ , count, elemt1, elment2, \u2026] ) : returns the array of removed elements. Starting from \u2018from\u2019 remove \u2018count\u2019 elements and replace them with elemts let arr1 = [1, 2, 3, 4, 5, 6] arr1.splice( 1, 2 ) // => [ 4, 5, 6] arr1 // [ 1, 2, 3 ] arr1 = [1, 2, 3, 4, 5, 6] arr1.splice(0, 2, \"hello\" ,\"world\"); // [ 1, 2 ] arr1 // [ \"hello\", \"world\", 3, 4, 5, 6 ] // we can use splice to insert with out deleting by setting count to 0 arr1.splice( 1, 0, \"great\" ) // [] arr1 // [\"hello\", \"great\", \"world\", 3, 4, 5, 6 ] // negative indexes are allowed arr1.splice( -4, 4) // [ 3, 4, 5, 6 ] arr1 // [ \"hello\", \"great\", \"world\" ] \u2699 Method **slice( start , end)**, works on arrays and strings and returns a subarray from index start to end or a substring if it\u2019s called on a string let str = \"hello\" let arr = ['h', 'e', 'l', 'l', 'o' ] str.slice(1, 4) // 'ell' arr.slice(1, 4) // [ 'e', 'l', 'l' ] str.slice(2) // 'llo' \u2699 Method array.concat( arg1, arg2, \u2026) : returns array concatenated with the arguments. If the argument is has a Symbol.isConcatSpreadable it will get spreaded and concatenated to array. if not it will be appended to the end of array as it is let arr = [ 1,2,3,4 ] arr.concat(\"yee\", \"haa\") // [ 1,2,3,4,\"yee\", \"haa\" ] arr // [ 1,2,3,4 ] concat doesn't alter arr let arr2 = [ \"ping\", \"pong\" ] arr.concat(\"I\", \"love\", arr2 ) // [ 1,2,3,4,\"I\", \"Love\", \"ping\", \"pong\" ] let obj = { 0 : 'yee', 1 : 'ha' , [Symbol.isConcatSpreadable] : true, } arr.concat(obj) // [ 1,2,3,4,'yee', 'ha'] \u2699 Method array.forEach(func) : allows you to run a function on each element of the array. functions called inside forEach get passed the arguments ( item, index, array ) > let arr = [ 1,2,3 ] > arr.forEach(console.log()); 1 0 [ 1, 2, 3, 4, 5, 6 ] 2 1 [ 1, 2, 3, 4, 5, 6 ] 3 2 [ 1, 2, 3, 4, 5, 6 ] > > let func = (item, index, array) => console.log(`item : ${item}, index : ${index}, array: ${array}`) > arr.forEach(func); item: 1, index: 0, array: 1,2,3,4,,5,6 item: 2, index: 1, array: 1,2,3,4,,5,6 item: 3, index: 2, array: 1,2,3,4,,5,6 Searching in an array \u2699 methods arr.**indexOf(item, from),** arr.**lastIndexOf(item, from),** arr.**includes(item, from)** do the same things as their string counter-parts, they use the === comparison. **** // one notable difference is const arr = [NaN]; arr.indexOf(NaN) // -1 arr.includes(NaN) // true \u2699 method arr.**find( function )** :- if function returns true, iteration is stopped and the item is returned, if false undefined is returned. const arr = [ { id: 1, age: 34 }, { id: 2, age: 23 }, { id: 3, age: 34 }, ] // to find element with id 2 arr.find( (item, index, array) => item.id == 2 ); // { id: 2, age: 23 } // to find element with age 23 arr.find( item => item.age == 23 ) // { id: 2, age: 23 } \u2699 method arr.**findIndex( function )** :- is the same as find() but, it returns the index if its found and -1 if not > let arr2 = [ 1,2,3,4,5 ] > arr2.findIndex( item => item == 3 ); 2 \u2699 method **arr.filter( function ) :-** is also the same as find() but it returns an array of objects that fulfill the condition. > arr.filter( item => item.age == 34 ); [ { id: 1, age: 34 }, { id: 3, age: 34 } ]","title":"Looping through arrays:"},{"location":"Data%20Types/#transforming-arrays","text":"\u2699 method arr.map(function) : returns a new array of the results of the function > let arr = [ 1,2,3,4,5 ] > arr.map(item => item + 1); [ 2,3,4,5,6 ] > [ \"a\", \"ab\", \"abc\" ].map( item => item.length ) [ 1,2,3 ] \u2699 method arr.**sort(func)** :- sorts arr based on func, if func is not given it will treat it like a string > [ 13, 5, 1].sort(); [ 1, 13, 5 ] // because it tried to sort it like a string /* if we want it to sort based on a function, we need to supply a function of two * arguments */ > function comp( a, b ) { if( a > b ) return 1; if( a < b ) return -1; if( a === b) return 0; } > [ 13, 5, 1].sort(comp); [ 1, 5, 13 ] /* compare functions are only required to return a positive number to say greate and a * negative number to say less, so we can do this instead */ > [ 13, 5, 1].sort( (a, b) => a - b ) [ 1, 5, 13] \u2699 method **arr.reverse()** :- reverses the array and returns it. it will change the array let ar = [ 1, 2, 3, 4 ] ar.reverse() // [ 4, 3, 2, 1 ] ar // [ 4, 3, 2, 1 ] split and join \u2699 method string.split(delimiter, limit) : splits a string into an array based on the delimiter \u2699 method arr.join(delimiter) : does the reverse of split() let str = \"hello , world\"; str.split() // [ \"hello , world\" ] str.split(\"\") // [ 'h', 'e', 'l', 'l', 'o', ' ' , ',', 'w' ...] arr = str.split(\",\") // [ \"hello \", \" world\" ] arr.join(\":\") // \"hello : world\" str.split(\",\", 1) // [ \"hello\" ] reduce and reduceRight \u2699 method arr.reduce( func( previous, item, index, array) ) :- reduces the array into a single value based on the function passed let arr = [ 'a', 'b', 'c', 'd' ] arr.reduce ( (prev, item) => prev + \",\" + item ); // 'a,b,c,d' let arr2 = [ 1, 2, 3, 4 ] arr2.reduce( (prev, current) => prev + current, 0 ); // 10 /* we can specify an initial prev after the comma, we gave it 0 above reduceRight() : does the same thing but does it from the right Array.isArray(arr) : returns true if arr is an array all array methods except sort() support an additional thisArg Array methods cheat-sheet","title":"Transforming arrays"},{"location":"Data%20Types/#iterables","text":"Iterables are objects that can be used by a for \u2026 of loop","title":"Iterables"},{"location":"Data%20Types/#symboliterator","text":"To make our on iterable objects we have to add a method called Symbol.iterator, which returns an iterator object which includes a method called next which returns an object of the format { done: boolean, value: next_value }. let range = { from: 1, to: 5, } range[Symbol.iterator] = function(){ return{ this.current = this.from, this.last = this.to, next(){ if(this.current <= this.last) return { done: false, value: this.current++ } else return {done: true} } } } for(i of range) console.log(i) // 1, 2, 3, 4, 5 The object we want to iterate over can be used as the iterator itself to make the code simpler let range = { from: 5, to: 10, [Symbol.iterator](){ this.current = this.from; return this } next(){ if(this.current <= this.to) return { done: false, value: this.current++} else return { done: true } } } for( i of range ) // 5 6 7 8 9 10 /* But this implementation won't allow us to run simultaneously because they will * share the same iteration state */ Calling an iterator explicitly We can iterate oven an iterable manually let str = \"hello\" let iterator = str[Symbol.iterator](); while(true){ let result = iterator.next(); if(result.done) break; console.log(result.value) } Iterables and array-likes Iterables are objects that implement the Symbol.iterator method and Array likes are those that have indexes and a length property. Array.from(obj, [mappingFunc, thisArg]) creates arrays from iterables or array-likes let a = Array.from(range) // the previous iterable a // [ 5,6,7,8,9,10 ] // we can pass a mapping function to be applied let b = Array.from(range, num => num*2 ) b // [10, 12, 14, 16, 18, 20 ] // to get array of characters from a string let str = \"hello\" let c = Array.from(str) // this approach unlike split, works fine with surrogate pairs","title":"Symbol.iterator"},{"location":"Data%20Types/#maps","text":"Maps are like objects in that they are keyed collections of data items, but unlike objects maps allow keys of any types. \ud83d\udea8 Main methods - **new Map()** - create a map - **map.set(key, value)** - stores the value by key - **map.get(key)** - gets value by key - **map.has(key)** - returns true if key exists - **map.delete(key)** - deletes value by key - **map.clear()** - clears the map - **map.size** - returns the size of the map let a = new Map() a.set(1, \"a\") a.set('1', \"b\") a.set(true, \"c\") a.get(1) // 'a' a.get('1') // 'b' a.get(true) // 'c' a.has(false) // false Every map.set() return the map itself so we can chain our sets a.set(1, \"a\").set('1', \"b\").set(true, \"c\") Maps from objects we can pass an array or other iterables with key value pairs when creating a map let a = new Map([ 1, \"a\"], [ \"2\", \"b\"], [ false, 4 ]); The method Object.entries(obj) creates a key value pair array from an object let obj = { name: \"dani\", age: 56, sex: \"male\" } let ent = Object.entries(obj); ent // [ [\"name\", \"dani\"], [\"age\", 56], [\"sex\", \"male\"] ] let m = new Map(ent); Iteration over maps maps.keys() - returns an iterable for keys maps.values() - returns an iterable for values maps.entries() - returns an iterable for entries, it\u2019s used by default in a for\u2026of loop > let m = new Map(Object.entries({ name: \"jim\", age: 45, height: 174 }) ); > for( i of m.keys() ) console.log(i) name age height > for( i of m.values() ) console.log(i) jim 45 174 > for( i of m ) console.log(i) // same as m.entries() [ \"name\", \"jim\" ] [ \"age\", 45 ] [ \"height\", 175 ]","title":"Maps"},{"location":"Data%20Types/#set","text":"A set is a collection of values where a value can only occur once. \ud83d\udea8 Methods **new Set( iterable )** - creates a set, if an iterable is given in copies it in **set.add( value )** - adds a value to a set **set.delete( value )** - removes a value from a set **set.has( value )** - checks to see if the set has that value **set.clear()** - clears the set **set.size** - elements count iterating over a set we can iterate over the set using a for.. of. loop of a forEach() let set = new Set( [ 1, 3, 5, 6 ] ) for( i of set ) console.log(i) // 1, 3, 5, 6 set.forEach( (value, valueAgain, map) => console.log(value) ) // 1, 3, 5, 6 /* The callback function called in forEach passes three arguments of which 2 are the * values, this is done for compatibility with maps. In this spirit sets also have * the methods to return iterables, set.keys(), set.values(), set.entries() * keys() and values() both return the values, and entries returns [ value, value ]*/","title":"Set"},{"location":"Data%20Types/#weakmap-and-weakset","text":"The garbage collector doesn\u2019t free up objects if they are referenced in arrays, maps or sets. let obj = { str: \"I'll live forever\" } let arr = new Array(obj); obj = null; arr // [ { str: \"I'll live forever\" } ] WeakMap and WeakSet don\u2019t prevent the garbage collector from doing it\u2019s job. WeakMaps and WeakSets WeakMaps can\u2019t have primitive values as their keys. WeakMaps don\u2019t support iteration. \ud83d\udea8 WeakMap methods **new WeakMap() -** creates a weak map **weakmap.get( key ) -** gets a value **weakmap.set( key, value ) weakmap.has( key ) weakmap.delete( key )** The garbage collector performs clean up at a time of it\u2019s choosing, so the size of weakmap can\u2019t be known, that\u2019s why the other methods can\u2019t operate on weakmaps. Weaksets are analogous to sets","title":"WeakMap and WeakSet"},{"location":"Data%20Types/#objectkeysobj-valuesobj-and-entriesobj","text":"Objects just like maps and sets also support these methods, but unlike maps and sets they return arrays and not iterables, let obj = { name: \"candy\", sweet: true } Object.keys(obj) // [ \"name\", \"sweet\" ] Object.values(obj) // [\"candy\", true ] These methods also ignore symbol properties, but we can use methods Object.getOwnPropertySymbols(obj) - to return only the symbolic keys and method Reflect.ownKeys(obj) - to get all the keys Object.fromEntries( [] ) - creates objects from entries, or maps let arr = [ [\"name\", \"candy\"], [\"sweet\",true] ] Object.fromEntries(arr) // { name: \"candy\", sweet: true } // also works on maps","title":"Object.keys(obj) .values(obj) and .entries(obj)"},{"location":"Data%20Types/#destructuring-assignment","text":"destructuring assignment is a special syntax that allows us to unpack arrays or objects in to variables. Array destructuring // Array destructuring let [ first, last ] = [ \"Barack\", \"Obama\" ] // we could also do this let [ first, last ] = \"Barack Obama\".split(\" \"); // we can skip over unwanted elements with commas We can use any iterable on the right side let map = new Map(); map.set(\"name\",\"jhon\").set(\"age\",8).set(\"height\", 174); let [ first, , last ] = map first // \"name\", \"jhon\" last // \"height\", 174 // or string [a, b, c] = \"1234\"; a // 1 b // 2 We can also store the rest of the elements of the array using \u2026var, with var being an array of everything else let arr = \"hello world this is javascript speaking\".split(\" \"); let [ a, b, ...c] = arr a // hello b // world c[0] // this c[1] // is When there are fewer elements in the array than the variables, the remaining variables are passed undefined. We can define default values for the variables if that happens let [ a = \"empty\", b = \"empty\"] = [\"hello\"] a // hello b // empty // the default values can also be calls to functions Object destructuring let obj = { name: \"Andy\", sex: \"male\", age: 13, } let { age, sex, name } = obj; // order doesn't matter If we want to assign the properties to variables with a different name we can use a colon let { name: n, sex, age: years } = obj For potentially missing values we can specify a default using = let { name, country = \"UK\", age } = obj name // \"Andy\" country // \"UK\" // default values can also be calls to functions If we want to combine both the equality and colon , we can do so as such let { name: n = \"Jhon\" } = obj If we want the rest of the objects properties we can use \u2026var, where var will be an object with the rest of the properties let { name, ...rest } = obj name // \"Andy\" rest // { sex: \"male\", age:13 } rest.age // 13 Nested destructuring If an object or array contains other objects and arrays we can use nested destructuring to extract the deeper portions. let box = { size: { width: 3, height: 5, depth: 2, }, colors: [ \"red\", \"green\" ], } let { size: { width, height, }, colors: [ color1, color2 ], } = box; width // 3 height // 5 color1 // red size // undefined colors // undefined","title":"Destructuring assignment"},{"location":"Data%20Types/#smart-function-parameters","text":"When we have many parameters of which several are optional, it can become hard to remember their position, we can work around this problem by using object destructuring. we can pass them objects and the use the function to destructurize them into variables. let movie = { title: \"Avengers\", genre: [ \"action\", \"drama\" ], }; function showMovie ( {title = \"no title\", duration = 2.00, genre} ){ console.log(` ${title} , ${duration} , ${genre} `); } showMovie(movie); // Avengers, 2.00, action, drama // we can also specify default values and new names function showMovie( { title: name = \"no title\", duration = 2.00, genre: [ g1 ]}) /* if we want all defaults we can't just do showMovie() but showMovie({}), to work * around this problem we can specify {} as a default for the whole parameter */ function showMovie( {title = \"no title\", genre: [g1, g2]} = {} ) {} // doing ={} will make it possible to just call showMovie()","title":"Smart function parameters"},{"location":"Data%20Types/#date","text":"Creation new Date() // without arguments creates a date object for the current date and time. new Date( milliseconds ) // creates a date object with the time equal to the number of milliseconds past since the Jan 1- 1970. The number of milliseconds past since since 1970 is called a timestamp new Date( date string ) \u2014 the date string get parsed with the Date.parse algorithm new Date( year, month, day, hours, minutes, seconds, milliseconds ) - The first two arguments are obligatory . Year must have four digits. month count starts from 0 - 11. default of day is 1. If the rest are missing they are assumed to be 0. new Date() // 2022-07-12T07:19:10.943Z -- current time new Date(0) // 1970-01-01T00:00:00.000Z new Date(\"2020-4-8\") // 2020-04-07T21:00:00.000Z new Date(1994, 4) // 1994-04-30T21:00:00.000Z new Date(2002, 9, 11, 4) // 2002-10-11T01:00:00.000Z Access date components getFullYear() - get the year ( 4 digit ) getMonth() - getDate() - getHours(), getMinutes(), getSeconds(), getMilliseconds() getDay() // 0-6 , where 0 is sunday // These methods also have UTC counterparts like getUTCHours(), getUTCMinutes() etc. getTime() // returns the date\u2019s timestamp since Jan1/ 1970 UTC+0. has no UTC variant getTimezoneOffset() // returns the difference b/n local time zone and UTC in minutes Modify date components setFullYear( year [, month, date ] ) setMonth( month [, date] ) setDate( date ) setHours( hours [, minutes, seconds, millis ] ) setMinutes( minutes [, seconds, millis ] ) setSeconds( seconds [, millis ] ) setMilliseconds( millis ) setTime ( timestamp ) Autocorrection let a = new Date(\"2002\\1\\30\"); a.setDate(a.getDate() + 4) a // 2002-02-02T21:00:00.000Z // we can use this technique to get the date after some time has elapsed a.setMinutes( a.getMinutes() + 40 ) // date after 40 minutes a.setSeconds( a.getSeconds() + 4900 ) // date after 4900 seconds We can also set numbers \u2264 0 let a = new Date(\"2002/2/23\"); a.setDate(0) // last day of previous month a.setDate(-3) // before 3 days and before 3 month for some reason Casting to numbers when dates get cast into numbers they return their timestamps. let a = new Date(2002, 1, 23); +a // 1014411600000 Date.parse() The string format should be: YYYY-MM-DDTHH:mm:ss.sssZ , where: YYYY-MM-DD \u2013 is the date: year-month-day. The character \"T\" is used as the delimiter. HH:mm:ss.sss \u2013 is the time: hours, minutes, seconds and milliseconds. The optional 'Z' part denotes the time zone in the format +-hh:mm . A single letter Z that would mean UTC+0.","title":"Date"},{"location":"Data%20Types/#json-javascript-object-notation","text":"Is a general format to represent Objects and values. It\u2019s a data only cross language specification. JSON.stringify() \u2014 converts objects in to strings, the resulting strings are called JSON-encoded or serialized or stringified or marshalled object. JSON.parse() \u2014 converts JSON into objects let obj = { name: \"my object\", description: 'an object', } let a = JSON.stringify(obj); a // '{\"name\":\"my object\",\"description\":\"an object\"}' typeof a // 'string' let b = JSON.parse(a); b // { name: 'my object', description: 'an object' } JSON-encoded objects - use only double quotes for strings, so \u2018an object\u2019 becomes \u201can object\u201d. They also double quote property names so name becomes \u201cname\u201d. JSON methods can natively be applied to objects, arrays, primitives(strings, numbers, booleans, and null) JSON.strigify() - skips methods, symbol properties, and properties that store undefined, since it\u2019s data only let obj = { method() { /* do smth */ }, prop1: undefined, [Symbol(\"id\")]: '01', } JSON.stringify(obj) // '{}' stringify() \u2014 supports nested objects, as long as there\u2019s no circular references. let room = { number: 23 }; let meetup = { title: \"Conference\", participants: [\"john\", \"ann\"] }; meetup.place = room; // meetup references room room.occupiedBy = meetup; // room references meetup JSON.stringify(meetup); // Error: Converting circular structure to JSON JSON.stringify( value [, replacer, space] ) where replacer is an array of properties to encode or a mapping function(key, value) and space is the amount of space to use for formatting. replacer passing an array let obj = { name: \"candy\", age: 50, other: [{height: 5.6}, {weight: 140}], sex: \"f\", } let s = JSON.stringify(obj, [\"name\", \"age\", \"other\", \"height\"]) s // '{\"name\": \"candy\", \"age\": 50, \"other\": [{\"height\": 5.6}, {}]}' // properties \"sex\" and \"weight\" are not encoded since they are not mentioned /* we can safely skip properties that cause circular references by not adding them * to the replacer array */ passing a function // let's make candy 12 years old let s = JSON.stringify(obj, (key, value) => { return key == \"age\" ? 12 : value; }); s // '{\"name\": \"candy\", \"age\": 12, \"other\": [{\"height\": 5.6}, {}]}' The first call passes a key value pair with the key(\u201d\u201d) and value of the object itself { \u201c\u201d: obj } spaces used to specify the number of spaces used for indentation, used for logging and output let obj = { continent: \"Africa\", countries: [ \"Ethiopia\", \"Mali\" ] } /* { \"continent\": \"Africa\", \"countries\": [ \"Ethiopia\", \"Mali\", ] } */ Custom toJSON conversion Just like toString() we can add a toJSON() method to our objects. JSON.stringify() calls this method if it exists let room = { number: 1, toJSON() { return this.number; } } JSON.stringify(room) // 1 JSON.parse(str [, reviver]) we can customize the parsing of json to objects by passing a reviving function. // consider the case let obj = { name: \"Elias\", dob: new Date() } let json = JSON.stringify(obj) json // '{\"name\":\"Elias\",\"dob\":\"2022-07-13T08:24:52.846Z\"}' let obj2 = JSON.parse(json) obj2 // { name: 'Elias', dob: '2022-07-13T08:24:52.846Z' } ! dob became a string let obj3 = JSON.parse(json, (key, value) => { return key == \"dob\" ? new Date(value) : value; }); obj3 // '{\"name\":\"Elias\",\"dob\":\"2022-07-13T08:24:52.846Z\"}'","title":"JSON - ( JavaScript Object Notation )"},{"location":"Object%20properties%20configuration/","text":"Object properties configuration Property flags and descriptors Object properties besides a value have three special attributes. writable, enumarable, and configurable. Object.getOwnPropertyDescriptor(obj, propertyName) We can list these attributes using Object.getOwnPropertyDescriptor(obj, propertyName) >> let obj = { name: \"Smith\", age: 23, } >> let descriptor = Object.getOwnPropertyDescriptor(obj, \"name\"); >> descriptor { value: 'Smith', writable: true, enumarable: true, configurable: true, } Writable - can be changed, otherwise is read only enumerable - get's listed in loops, otherwise not configurable - property can get deleted, and these attributes can be modified, or else not Object.defineProperty( obj, property, descriptor) To change the flags we can use Object.defineProperty( obj, property, descriptor) >> Object.definePropery(obj, age, {value: 4, writable: false}); >> Object.getOwnPropertyDescriptor(obj, \"age\") { value: 4, writable: false, enumarable: true, configurable: true, } If the propery exists , defineProperty updates it's flags, if it doesn't, it will create the property and set all unspecified flags as false. >> Object.defineProperty(obj, height, {value: 174}); >> let desc = Object.getOwnPropertyDescriptor(obj, \"height\"); >> desc { value: 174, writable: false, enumerable: false, configurable: false } The effects of the flags writable - If we try to change the value of a non writable ( read only ) property, in strict mode it will cause an error, and if we are not in strict mode it will simply ingnore it. let user = {}; Object.defineProperty(user, \"name\", {value: \"Andy\"}); user.name = \"candy\" // if we are in strict mode this will cause an error // in non-strict mode flag violating operations will simply get ignored user.name // \"Andy\" enumerable - If this flag for a property is false, then it won't get show listed in a for...in , and it will also get excluded from an Object.keys >> let user = { name: \"andy\", toString(){ return this.name } } >> Object.keys(user); ['name', 'toString'] >> Object.defineProperty(user, \"toString\", {enumerable: false}); >> for( i in user) console.log(i); 'name' configurable - A non-configurable property can't get deleted or modified by another Object.defineProperty() , trying to do so will cause an error. Object.defineProperties(obj, descriptors) Allows us to define multiple properties at once. Object.defineProperties(obj, descriptors) . It returns the object let user = {} Object.defineProperties(user, { name: {value: \"max\", writable: true, enumerable: true}, age: {value: 10, writable: true, enumerable: true} }) Object.getOwnPropertyDescriptors(obj) returns an object with all the properties of obj, and their descriptors. This method can be used to create a flag aware clone of an object. let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj)); Sealing an object globally There are methods which limit access to whole objects. These methods are rarely used in practice Object.preventExtension(obj) Forbids addition of new properties to a obj Object.seal(obj) Forbids adding/ removing of properties, set's configurable: false for all existing properties Object.freeze(obj) Forbids adding/removing/changing of properties, set's writable: false, configurable: false for all existing properties. Object.isExtensible(obj) returns true if obj is extensible Object.isSealed(obj) returns true if obj is sealed Object.isFrozen(obj) returns true if obj is frozen Getter and Setter properties There are two types of properties, data properties and accessor properties . Accessor properties are essentially functions that work on getting and setting properties. They are denoted by get and set literals. // Their syntax let obj = { get propName(){} set propName(value){} } Let's declare a fullname accessor property inside object user let user = { firstName: \"Biruk\", lastName: \"Tesfa\", get fullName(){ return `${this.firstName} ${this.lastName}` } set fullName(str){ [this.firstName, this.lastName] = str.split(\" \"); } } user.firstName // 'Biruk' typeof user.fullName // String user.fullName // 'Biruk Tesfa' user.fullName = \"Girma Taye\" user.fullName // 'Girma Taye' user.firstName // 'Girma' user.lastName // 'Taye' accessor property's descriptors Descriptors for accessor properties, have no value and writable fields but they have get - function set - function with one argument enumerable configurable We can use Object.defineProperty() to create accessor properties let obj = {} Object.defineProperty(obj, \"propName\", { get(){}, set(arg){}, enumerable: true, }) Object.getOwnProperties(obj); /* { propName: { get: [Function: get], set: [Function: set], enumerable: true, configurable: false } } */ If we run the following code Object.defineProperty(obj, \"propName\", {value: \"smth\";}) Then propName will no longer be an accessor method but a data property. If we try to pass a descriptor containing, say a value or a writable and a get or set , it will give us a TypeError because we can't specify both an accessor and a value attribute. Getters and Setters can be used as wrappers over data properties to gain more control over them. let obj = { get average(){ return this._average}, set average(value){ if(value < 0 || value > 100) return; this._average = value; } } obj.average // undefined obj.average = -2 // will revert because value passed is < 0 obj.average // undefined obj.average = 79 obj.average // 79 // we can also call _average directly obj._average // 79 // But it's attributes that start with underscore are regarded to be internal and // we should not directly interact with them from outside.","title":"Object properties configuration"},{"location":"Object%20properties%20configuration/#object-properties-configuration","text":"","title":"Object properties configuration"},{"location":"Object%20properties%20configuration/#property-flags-and-descriptors","text":"Object properties besides a value have three special attributes. writable, enumarable, and configurable.","title":"Property flags and descriptors"},{"location":"Object%20properties%20configuration/#objectgetownpropertydescriptorobj-propertyname","text":"We can list these attributes using Object.getOwnPropertyDescriptor(obj, propertyName) >> let obj = { name: \"Smith\", age: 23, } >> let descriptor = Object.getOwnPropertyDescriptor(obj, \"name\"); >> descriptor { value: 'Smith', writable: true, enumarable: true, configurable: true, } Writable - can be changed, otherwise is read only enumerable - get's listed in loops, otherwise not configurable - property can get deleted, and these attributes can be modified, or else not","title":"Object.getOwnPropertyDescriptor(obj, propertyName)"},{"location":"Object%20properties%20configuration/#objectdefinepropertiesobj-descriptors","text":"Allows us to define multiple properties at once. Object.defineProperties(obj, descriptors) . It returns the object let user = {} Object.defineProperties(user, { name: {value: \"max\", writable: true, enumerable: true}, age: {value: 10, writable: true, enumerable: true} })","title":"Object.defineProperties(obj, descriptors)"},{"location":"Object%20properties%20configuration/#objectgetownpropertydescriptorsobj","text":"returns an object with all the properties of obj, and their descriptors. This method can be used to create a flag aware clone of an object. let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));","title":"Object.getOwnPropertyDescriptors(obj)"},{"location":"Object%20properties%20configuration/#sealing-an-object-globally","text":"There are methods which limit access to whole objects. These methods are rarely used in practice Object.preventExtension(obj) Forbids addition of new properties to a obj Object.seal(obj) Forbids adding/ removing of properties, set's configurable: false for all existing properties Object.freeze(obj) Forbids adding/removing/changing of properties, set's writable: false, configurable: false for all existing properties. Object.isExtensible(obj) returns true if obj is extensible Object.isSealed(obj) returns true if obj is sealed Object.isFrozen(obj) returns true if obj is frozen","title":"Sealing an object globally"},{"location":"Object%20properties%20configuration/#getter-and-setter-properties","text":"There are two types of properties, data properties and accessor properties . Accessor properties are essentially functions that work on getting and setting properties. They are denoted by get and set literals. // Their syntax let obj = { get propName(){} set propName(value){} } Let's declare a fullname accessor property inside object user let user = { firstName: \"Biruk\", lastName: \"Tesfa\", get fullName(){ return `${this.firstName} ${this.lastName}` } set fullName(str){ [this.firstName, this.lastName] = str.split(\" \"); } } user.firstName // 'Biruk' typeof user.fullName // String user.fullName // 'Biruk Tesfa' user.fullName = \"Girma Taye\" user.fullName // 'Girma Taye' user.firstName // 'Girma' user.lastName // 'Taye'","title":"Getter and Setter properties"},{"location":"Object%20properties%20configuration/#accessor-propertys-descriptors","text":"Descriptors for accessor properties, have no value and writable fields but they have get - function set - function with one argument enumerable configurable We can use Object.defineProperty() to create accessor properties let obj = {} Object.defineProperty(obj, \"propName\", { get(){}, set(arg){}, enumerable: true, }) Object.getOwnProperties(obj); /* { propName: { get: [Function: get], set: [Function: set], enumerable: true, configurable: false } } */ If we run the following code Object.defineProperty(obj, \"propName\", {value: \"smth\";}) Then propName will no longer be an accessor method but a data property. If we try to pass a descriptor containing, say a value or a writable and a get or set , it will give us a TypeError because we can't specify both an accessor and a value attribute. Getters and Setters can be used as wrappers over data properties to gain more control over them. let obj = { get average(){ return this._average}, set average(value){ if(value < 0 || value > 100) return; this._average = value; } } obj.average // undefined obj.average = -2 // will revert because value passed is < 0 obj.average // undefined obj.average = 79 obj.average // 79 // we can also call _average directly obj._average // 79 // But it's attributes that start with underscore are regarded to be internal and // we should not directly interact with them from outside.","title":"accessor property's descriptors"},{"location":"Objects/","text":"Objects An object is a key: value pair collection. Object properties can only be of type string or symbol. Properties of other types are casted into strings let user = new Object(); // object constructor syntax let user = {}; // object literal syntax let user = { name: \"no-name\", age: 6, \"favorite book\": \"Harry poter\", // multiword identifiers } user.name // no-name user[\"name\"] // no-name user['age'] // 5 user.favorite book // error user.\"favorite book\" // error user[\"favorite book\"] // harry poter user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' } user[\"profession\"] // undefinedd user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' } user[\"profession\"] = \"nurse\"; user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' , profession: 'nurse' } user.height = 7.8; user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' , // profession: 'nurse', height: 7.8 } delete user.heigth; user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' , profession: 'nurse' } computed properties [ ] denote computed properties // we can use computed properties in two ways let user = { name: \"smt\", age: 5, } let key = \"name\"; user[key] // -> smt , [] will compute the evaluate key to name // in declaration key = \"name\"; user = { [key]: \"nameless\" [ \"$\".repeat(5) ]: \"smth\", } user // { name: \"nameless\", '$$$$$': \"smth\" } \u26a0\ufe0f Reserved key words are allowed as property names let user = { for: 'smth', let: 'smth else', } // __proto__ . is allowed but will cause issues \u26a1 Property value shorthand (name, age) => { return { name: name, age: age, } } // is the same as (name, age) => { return { name, age } } // we can mix them up if we like (name, age) => { return { name, age, height: 1.78 } } \u26a0\ufe0f **Checking for existence** If a property doesn\u2019t exist and we try to access it, it will return undefined. we can use this user.property === undefined // it doesn't exist /* checking if it === undefined will fail if the property exists by contains undefined*/ /* We can also use the (in) operator \"key\" in object key in object */ let user = { key: 45, tag: 4, 1: 8, } let m = \"tag\"; \"key\" in user // true m in user // true -- variable m containig the name \" tag \" got tested 1 in user // true \"1\" in user // true \ud83d\udccc The for \u2026 in \u2026 loop for( key in object ); // iterates over the propeties of objects, typeof(key) -> string Integer properties are sorted, others appear in order of creation . //if we don't want our integer property names to be sorted we can cheat by adding + let code = {\"+1\": 4, \"+4\": 9,} \u26a0\ufe0f Object variables store references //because of this == and === on objects equate the referances // and const objects can be changed without changing their reference const a = { name: \"cara\" } a.name = \"jhon\" // will work a = {} // error cloning objects There are several way for cloning objects let obj1 = { p1: 1, p2: 2 } let obj2 = {} // using for... in for( key in obj1 ) { obj2[key] = obj1[key] } // using Object.assign() // Object.assing(dest, [arg1, arg2, ...] ) => returns dest // we can use it to copy multiple objects into one // the destination objects properties will be overwritten if they already exist obj2 = Object.assign({}, obj1); // or simply Object.assign(obj2, obj1) \u26a0\ufe0f READ GARBAGE COLLECTION A general book \u201cThe Garbage Collection Handbook: The Art of Automatic Memory Management\u201d (R. Jones et al) covers some of them. Symbols: A symbol value represents a unique value. // symbols can be created like let l = Symbol([description string]); let m = Symbol.for(\"smth\"); // global Symbols Symbols don\u2019t auto-convert into strings To use symbols as object properties we can do the following let sym = Symbol(); let sym2 = Symbol(); let obj = { [sym]: \"smth\" } ; obj[sym2] = \"smth else\"; Hiding symbolic properties principle Symbols are skipped in a for\u2026 in loop Symbols are skipped in a Object .keys(object) \u26a0\ufe0f In contrast Object.assign(), copies both string and symbolic properties \ud83c\udf10 Global symbols: If we want to access the same symbols from different parts of our code we can use the global symbol registry. We can do that by creating symbols by using ( Symbol .for([\u201ddescription\u201d]). if there exists a symbol with a matching description it will be returned otherwise it will be created let a = Symbol.for(\"abc\"); let b = Symbol.for(\"abc\"); a == b // true Symbol.keyFor(a) // abc // System Symbols Symbol.hasInstance Symbol.toPrimitive // and etc // Symbols are not really hidden // we can use Object.getOwnPropertySymbols(obj) // return symbol properties Reflect.ownKeys(obj) // returns all keys including symbolic ones Methods Are properties of an object that are functions // ways to declare methods let a = { } a.method1 = function () { /* */ } func2 = function() { } let b = { } b.func2 = func2 let c = { func3: function(){} func4() { } // short hand } // this. keyword let user = { name: \"usr1\", sayHi(){ console.log(\"hi \" + this.name); } } \ud83d\udc49\ud83c\udfff this. is evaluated at runtime, so the following things are possible let f = function() { alert(this.id) } let o1 = { id: 1 } let o2 = { id: 2 } o1.f = f o2.f = f o1.f() // 1 o2.f() // 2 /* this. is not bound i.e. it can be called anywhere, if it has no * referance, it will return the window object if it's no in strict mode * and undefined if it is in strict mode */ Reference type: The way method calls work, is by breaking up the process in to two operations obj.func() // there are two operations here, 1- the dot operator, and 2- () /* In method calls, the dot operator doesn't return a function but a special * intermediate internal reference type with the purpose of passing info from * the dot operator to the parenthesis, its composed of: * 1. base (i.e. the object) * 2. name (i.e. the property name) * 3. strict(i.e. bool whether it's in strict mode) * when the parenthesis are called on the reference type, they recieve full info * about the object and it's methods, so this. will work * other operations like assignment( a = obj.func ), discard the reference type and * return the function instead. */ let obj = { id: \"01\", printId() { alert(\"id: \" + this.id ) } } obj.printId() // id: 01 let func = obj.printId func() // id: undefined \ud83d\udc49\ud83c\udfff Arrow functions have no this, if this. is used inside them it\u2019s taken from the outer context object to primitive conversion All objects are true in Boolean context. there are only numeric and string conversions During object to primitive conversion, JavaScript tries to find and call three object methods. Symbol.toPrimitive(hint) is called if it exists, hint is either \u201cstring\u201d , \u201cnumber\u201d, or \u201cdefault\u201d , hint is the type of the conversion, \u201cdefault\u201d is called when the conversion is unclear, eg ( the binary + operator) can add numbers and concat strings and also the == operator resolves to \u2018default\u2019 for \u201cstring\u201d hints , it tries to find and do toString() then valueOf() for non-string hints, valueOf() \u2192 toString() All built in Objects except Date implement \u2018default\u2019 as number. >< resolve to \u2018number\u2019 let user = { name: \"jhon\", salary: 4000, [Symbol.toPrimitive](hint){ console.log(hint); return hint == 'string' ? this.name : this.salary; } } console.log(+user) // number -> 4000 console.log(`${user}`) // string -> jhon console.log(user + 2) // default -> 4002 /// let usrz = { name: \"dani\", age: 15, toString(){ console.log(\"inside toString...\"); return `toString -> ${this.name}` }, valueOf(){ console.log(\"inside valueOf...\") return this.age } } `${usrz}` // inside toString... -> dani +usrz // inside valueOf... -> 15 usrz + 1 // inside valueOf... -> 15 /* toString() and valueOf() must return a primitive and not an object */ /* if toPrimitive doesn't return a primitive there will be an error */ constructors, and the new keyword we can use constructors to create multiple similar objects, instead of using the regular {\u2026} syntax. constructor are like any other functions except for being called with the new operator and starting with capital letters. function User(name, age) { // this = {} ;implicitly this.name = name; this.age = age; this.happy = true; // we can also add methods this.smile = function(){ console.log(\"Smiling..\") } // return this; implicitly } let usr1 = new User(\"dani\", 20); To create a single object with new let user = new function(){ this.name ... } To know if a function got called with new or not we can user new.target let funky = function() { if(new.target) return \"called with new\"; return \"called without\"; } funky() // called without new funky() // called with new // this can be used to make functions a constructor regardless of the use of new function User(name) { this.name = name; if(!new.target) return new User(name) } \ud83d\udc49\ud83c\udfff Return in Constructors if there is a return in a constructor, and it returns an object , it will override this by returning the object, and if a primitive is returned it will be ignored. \ud83d\udc49\ud83c\udfff We can omit parenthesis if constructor has no arguments function Man() { this.sex = 'male' } let man = new Man","title":"Objects"},{"location":"Objects/#objects","text":"An object is a key: value pair collection. Object properties can only be of type string or symbol. Properties of other types are casted into strings let user = new Object(); // object constructor syntax let user = {}; // object literal syntax let user = { name: \"no-name\", age: 6, \"favorite book\": \"Harry poter\", // multiword identifiers } user.name // no-name user[\"name\"] // no-name user['age'] // 5 user.favorite book // error user.\"favorite book\" // error user[\"favorite book\"] // harry poter user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' } user[\"profession\"] // undefinedd user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' } user[\"profession\"] = \"nurse\"; user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' , profession: 'nurse' } user.height = 7.8; user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' , // profession: 'nurse', height: 7.8 } delete user.heigth; user // { name: 'no-name', age: 6, 'favorite book': 'harry poter' , profession: 'nurse' }","title":"Objects"},{"location":"Objects/#computed-properties","text":"[ ] denote computed properties // we can use computed properties in two ways let user = { name: \"smt\", age: 5, } let key = \"name\"; user[key] // -> smt , [] will compute the evaluate key to name // in declaration key = \"name\"; user = { [key]: \"nameless\" [ \"$\".repeat(5) ]: \"smth\", } user // { name: \"nameless\", '$$$$$': \"smth\" } \u26a0\ufe0f Reserved key words are allowed as property names let user = { for: 'smth', let: 'smth else', } // __proto__ . is allowed but will cause issues \u26a1 Property value shorthand (name, age) => { return { name: name, age: age, } } // is the same as (name, age) => { return { name, age } } // we can mix them up if we like (name, age) => { return { name, age, height: 1.78 } } \u26a0\ufe0f **Checking for existence** If a property doesn\u2019t exist and we try to access it, it will return undefined. we can use this user.property === undefined // it doesn't exist /* checking if it === undefined will fail if the property exists by contains undefined*/ /* We can also use the (in) operator \"key\" in object key in object */ let user = { key: 45, tag: 4, 1: 8, } let m = \"tag\"; \"key\" in user // true m in user // true -- variable m containig the name \" tag \" got tested 1 in user // true \"1\" in user // true \ud83d\udccc The for \u2026 in \u2026 loop for( key in object ); // iterates over the propeties of objects, typeof(key) -> string Integer properties are sorted, others appear in order of creation . //if we don't want our integer property names to be sorted we can cheat by adding + let code = {\"+1\": 4, \"+4\": 9,} \u26a0\ufe0f Object variables store references //because of this == and === on objects equate the referances // and const objects can be changed without changing their reference const a = { name: \"cara\" } a.name = \"jhon\" // will work a = {} // error","title":"computed properties"},{"location":"Objects/#cloning-objects","text":"There are several way for cloning objects let obj1 = { p1: 1, p2: 2 } let obj2 = {} // using for... in for( key in obj1 ) { obj2[key] = obj1[key] } // using Object.assign() // Object.assing(dest, [arg1, arg2, ...] ) => returns dest // we can use it to copy multiple objects into one // the destination objects properties will be overwritten if they already exist obj2 = Object.assign({}, obj1); // or simply Object.assign(obj2, obj1) \u26a0\ufe0f READ GARBAGE COLLECTION A general book \u201cThe Garbage Collection Handbook: The Art of Automatic Memory Management\u201d (R. Jones et al) covers some of them.","title":"cloning objects"},{"location":"Objects/#symbols","text":"A symbol value represents a unique value. // symbols can be created like let l = Symbol([description string]); let m = Symbol.for(\"smth\"); // global Symbols Symbols don\u2019t auto-convert into strings To use symbols as object properties we can do the following let sym = Symbol(); let sym2 = Symbol(); let obj = { [sym]: \"smth\" } ; obj[sym2] = \"smth else\"; Hiding symbolic properties principle Symbols are skipped in a for\u2026 in loop Symbols are skipped in a Object .keys(object) \u26a0\ufe0f In contrast Object.assign(), copies both string and symbolic properties \ud83c\udf10 Global symbols: If we want to access the same symbols from different parts of our code we can use the global symbol registry. We can do that by creating symbols by using ( Symbol .for([\u201ddescription\u201d]). if there exists a symbol with a matching description it will be returned otherwise it will be created let a = Symbol.for(\"abc\"); let b = Symbol.for(\"abc\"); a == b // true Symbol.keyFor(a) // abc // System Symbols Symbol.hasInstance Symbol.toPrimitive // and etc // Symbols are not really hidden // we can use Object.getOwnPropertySymbols(obj) // return symbol properties Reflect.ownKeys(obj) // returns all keys including symbolic ones","title":"Symbols:"},{"location":"Objects/#methods","text":"Are properties of an object that are functions // ways to declare methods let a = { } a.method1 = function () { /* */ } func2 = function() { } let b = { } b.func2 = func2 let c = { func3: function(){} func4() { } // short hand } // this. keyword let user = { name: \"usr1\", sayHi(){ console.log(\"hi \" + this.name); } } \ud83d\udc49\ud83c\udfff this. is evaluated at runtime, so the following things are possible let f = function() { alert(this.id) } let o1 = { id: 1 } let o2 = { id: 2 } o1.f = f o2.f = f o1.f() // 1 o2.f() // 2 /* this. is not bound i.e. it can be called anywhere, if it has no * referance, it will return the window object if it's no in strict mode * and undefined if it is in strict mode */ Reference type: The way method calls work, is by breaking up the process in to two operations obj.func() // there are two operations here, 1- the dot operator, and 2- () /* In method calls, the dot operator doesn't return a function but a special * intermediate internal reference type with the purpose of passing info from * the dot operator to the parenthesis, its composed of: * 1. base (i.e. the object) * 2. name (i.e. the property name) * 3. strict(i.e. bool whether it's in strict mode) * when the parenthesis are called on the reference type, they recieve full info * about the object and it's methods, so this. will work * other operations like assignment( a = obj.func ), discard the reference type and * return the function instead. */ let obj = { id: \"01\", printId() { alert(\"id: \" + this.id ) } } obj.printId() // id: 01 let func = obj.printId func() // id: undefined \ud83d\udc49\ud83c\udfff Arrow functions have no this, if this. is used inside them it\u2019s taken from the outer context","title":"Methods"},{"location":"Objects/#object-to-primitive-conversion","text":"All objects are true in Boolean context. there are only numeric and string conversions During object to primitive conversion, JavaScript tries to find and call three object methods. Symbol.toPrimitive(hint) is called if it exists, hint is either \u201cstring\u201d , \u201cnumber\u201d, or \u201cdefault\u201d , hint is the type of the conversion, \u201cdefault\u201d is called when the conversion is unclear, eg ( the binary + operator) can add numbers and concat strings and also the == operator resolves to \u2018default\u2019 for \u201cstring\u201d hints , it tries to find and do toString() then valueOf() for non-string hints, valueOf() \u2192 toString() All built in Objects except Date implement \u2018default\u2019 as number. >< resolve to \u2018number\u2019 let user = { name: \"jhon\", salary: 4000, [Symbol.toPrimitive](hint){ console.log(hint); return hint == 'string' ? this.name : this.salary; } } console.log(+user) // number -> 4000 console.log(`${user}`) // string -> jhon console.log(user + 2) // default -> 4002 /// let usrz = { name: \"dani\", age: 15, toString(){ console.log(\"inside toString...\"); return `toString -> ${this.name}` }, valueOf(){ console.log(\"inside valueOf...\") return this.age } } `${usrz}` // inside toString... -> dani +usrz // inside valueOf... -> 15 usrz + 1 // inside valueOf... -> 15 /* toString() and valueOf() must return a primitive and not an object */ /* if toPrimitive doesn't return a primitive there will be an error */","title":"object to primitive conversion"},{"location":"Objects/#constructors-and-the-new-keyword","text":"we can use constructors to create multiple similar objects, instead of using the regular {\u2026} syntax. constructor are like any other functions except for being called with the new operator and starting with capital letters. function User(name, age) { // this = {} ;implicitly this.name = name; this.age = age; this.happy = true; // we can also add methods this.smile = function(){ console.log(\"Smiling..\") } // return this; implicitly } let usr1 = new User(\"dani\", 20); To create a single object with new let user = new function(){ this.name ... } To know if a function got called with new or not we can user new.target let funky = function() { if(new.target) return \"called with new\"; return \"called without\"; } funky() // called without new funky() // called with new // this can be used to make functions a constructor regardless of the use of new function User(name) { this.name = name; if(!new.target) return new User(name) } \ud83d\udc49\ud83c\udfff Return in Constructors if there is a return in a constructor, and it returns an object , it will override this by returning the object, and if a primitive is returned it will be ignored. \ud83d\udc49\ud83c\udfff We can omit parenthesis if constructor has no arguments function Man() { this.sex = 'male' } let man = new Man","title":"constructors, and the new keyword"},{"location":"Prototypes%20and%20Inheritance/","text":"Prototypal inheritance Objects have a hidden specification property [ [ Prototype ] ] that is either null or a referance to another object. If object B prototypically inherits from object A , and we try to read a property from B and it's missing, JS automatically tries to take it from A , this is called prototypal inheritance . Even though the [ [ Prototype] ] property is hidden, there are several ways to set it, one of them is proto proto let animal = { move(){}, breate(){alert(\"moving\")} } let mammal = { giveBirth(){} breastFeed(){} } mammal.__proto__ = animal; mammal.move() // moving // we can add other Objects which inherit from mammal let avian = { shitOnCars() {} __proto__ : animal; } // we can make the inheritance chain longer let human = { __proto__: mammal; inventStuff(){}; } The only limitations to inheritance are that References can't go in circles The value of __proto__ can either be null or an object In modern language proto is replaced by methods like Object.getPrototypeOf and Object.setPrototypeOf If we try to write to inherited data properties we will simply be overriding them. let animal = { move(){ alert(\"animal on the move\"); } } let mammal = { __proto__: animal; } mammal.move = function(){ alert(\"A mammal on the move\"); } mammal.move() // A mammal on the move In prototypal inheritance methods can be shared but not object state i.e. this let animal = { walk(){ if(!this.isSleeping) alert(\"I'm walking\") }, sleep(){ this.isSleeping = true; } } let rabbit = { __proto__ : animal; name: \"White Rabbit\" } rabit.sleep(); rabit.isSleeping // true animal.isSleeping // undefined for...in loop A for...in loop iterates over inherited properties too. obj.hasOwnProperty(key) This method returns true if obj has it's own uninherited property named key F.prototype The way Objects get prototypes when they are created with a constructor i.e. using the new keyword, is a bit different. Every function has a prototype property even if we don't supply it. And if F.prototype is an object, the new operator will automatically set it as the [ [prototype] ] for the new Object. let animal = { eats: true; } let Rabbit(name){ this.name = name; } Rabbit.prototype = animal; let rabbit = new Rabbit(\"Fluffy\"); rabbit.eats // true If after the creation of the an object, the prototype of the constructor changes, the former object will retain the old prototype, but new object created with the constructor will have the new prototype All objects have a constructor property. The default prototype for a function is an object with the only property constructor that points back to the function itself, like so. let Plant(species){ this.species = species; this.hasRoot = true; /* default prototype this.prototype = {constructor: Plant} */ } let rose = new Plant(\"Rosa\"); // If we want to check which constructor rose was created with rose.constructor // [Function: Plant] Native prototypes The prototype property is also widely used in the core of javascript as well. let obj = {} // when obj is created the default new Object() constructor is used internally obj.constructor // [Function : Object] Object.prototype == obj.__proto__ // true // methods like toString() hasOwnProperty() etc, get inherited from the prototype // of the object constructor Other built-in Objects such as Array Date and Function also keep their methods prototypes. By specification all built in prototypes have Object.prototype at the top. ![[Screenshot from 2022-07-30 13-02-17.png]] let arr = [] arr.__proto__ == Array.prototype // true arr.__proto__.__proto__ == Object.prototype // true arr.__proto__.__proto__.__proto__ // Null primitives Primitives are not objects, but if we try to access their properties, then temporary wrapper objects will be created using the built-in constructors String Number and Boolean . The methods of these objects also reside in prototypes. They are available as String.prototype Number.prototype Boolean.prototype values null and undefined stand apart in that they have no Object wrappers. We can modify native prototypes. String.prototype.show = function(){ console.log(this.toString()); } // the show() method will become available for all Strings \"Hello\".show() // prints out Hello","title":"Prototypal inheritance"},{"location":"Prototypes%20and%20Inheritance/#prototypal-inheritance","text":"Objects have a hidden specification property [ [ Prototype ] ] that is either null or a referance to another object. If object B prototypically inherits from object A , and we try to read a property from B and it's missing, JS automatically tries to take it from A , this is called prototypal inheritance . Even though the [ [ Prototype] ] property is hidden, there are several ways to set it, one of them is proto","title":"Prototypal inheritance"},{"location":"Prototypes%20and%20Inheritance/#proto","text":"let animal = { move(){}, breate(){alert(\"moving\")} } let mammal = { giveBirth(){} breastFeed(){} } mammal.__proto__ = animal; mammal.move() // moving // we can add other Objects which inherit from mammal let avian = { shitOnCars() {} __proto__ : animal; } // we can make the inheritance chain longer let human = { __proto__: mammal; inventStuff(){}; } The only limitations to inheritance are that References can't go in circles The value of __proto__ can either be null or an object In modern language proto is replaced by methods like Object.getPrototypeOf and Object.setPrototypeOf If we try to write to inherited data properties we will simply be overriding them. let animal = { move(){ alert(\"animal on the move\"); } } let mammal = { __proto__: animal; } mammal.move = function(){ alert(\"A mammal on the move\"); } mammal.move() // A mammal on the move In prototypal inheritance methods can be shared but not object state i.e. this let animal = { walk(){ if(!this.isSleeping) alert(\"I'm walking\") }, sleep(){ this.isSleeping = true; } } let rabbit = { __proto__ : animal; name: \"White Rabbit\" } rabit.sleep(); rabit.isSleeping // true animal.isSleeping // undefined for...in loop A for...in loop iterates over inherited properties too.","title":"proto"},{"location":"Prototypes%20and%20Inheritance/#objhasownpropertykey","text":"This method returns true if obj has it's own uninherited property named key","title":"obj.hasOwnProperty(key)"},{"location":"Prototypes%20and%20Inheritance/#fprototype","text":"The way Objects get prototypes when they are created with a constructor i.e. using the new keyword, is a bit different. Every function has a prototype property even if we don't supply it. And if F.prototype is an object, the new operator will automatically set it as the [ [prototype] ] for the new Object. let animal = { eats: true; } let Rabbit(name){ this.name = name; } Rabbit.prototype = animal; let rabbit = new Rabbit(\"Fluffy\"); rabbit.eats // true If after the creation of the an object, the prototype of the constructor changes, the former object will retain the old prototype, but new object created with the constructor will have the new prototype All objects have a constructor property. The default prototype for a function is an object with the only property constructor that points back to the function itself, like so. let Plant(species){ this.species = species; this.hasRoot = true; /* default prototype this.prototype = {constructor: Plant} */ } let rose = new Plant(\"Rosa\"); // If we want to check which constructor rose was created with rose.constructor // [Function: Plant]","title":"F.prototype"},{"location":"Prototypes%20and%20Inheritance/#native-prototypes","text":"The prototype property is also widely used in the core of javascript as well. let obj = {} // when obj is created the default new Object() constructor is used internally obj.constructor // [Function : Object] Object.prototype == obj.__proto__ // true // methods like toString() hasOwnProperty() etc, get inherited from the prototype // of the object constructor Other built-in Objects such as Array Date and Function also keep their methods prototypes. By specification all built in prototypes have Object.prototype at the top. ![[Screenshot from 2022-07-30 13-02-17.png]] let arr = [] arr.__proto__ == Array.prototype // true arr.__proto__.__proto__ == Object.prototype // true arr.__proto__.__proto__.__proto__ // Null","title":"Native prototypes"},{"location":"Prototypes%20and%20Inheritance/#primitives","text":"Primitives are not objects, but if we try to access their properties, then temporary wrapper objects will be created using the built-in constructors String Number and Boolean . The methods of these objects also reside in prototypes. They are available as String.prototype Number.prototype Boolean.prototype values null and undefined stand apart in that they have no Object wrappers. We can modify native prototypes. String.prototype.show = function(){ console.log(this.toString()); } // the show() method will become available for all Strings \"Hello\".show() // prints out Hello","title":"primitives"},{"location":"The%20Basics/","text":"The Basics If we give a src attribute inside our <script> tag, and at the same time define some code inside the <script> tags, the script inside will get ignored <script src=\"smt.js\"> console.log('hello'); // this code will get ignored </script> <aside> \ud83d\udca1 As a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files. The benefit of a separate file is that the browser will download it and store it in its cache. Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once. That reduces traffic and makes pages faster. </aside> ```jsx \"use strict\"; // we can do ^ this to switch the engine to modern mode // they must be at the top // we can also use them in functions // several language features like classes and modules enable strict mode by default we can declare multiple variables in one line let name=\"jim\", age=8n, height=45.4n; \u26a0\ufe0f **\u201cstrict\u201d mode alert** \ud83d\udd25 We could create variables without declaration merely through assignment, but this is not allowed in strict mode. Dynamically typed- there are datatypes but variables are not bound to them. The 7 basic Datatypes: Number: integers and floating point numbers, plus Special numeric values (Infinity, -Infinity, NaN ). Infinity is a result of division by 0. It\u2019s greater than any number. NaN is the result of a computational error. If there is a NaN inside a mathematical expression it will propagate through the whole expression. Doing math in JS is safe, i.e. it won\u2019t die with a fatal error, it will result in a NaN in the worst case Strings: can be surrounded with \u201c\u201d \u2018\u2019 or backticks(``). Booleans: either true or false Null: In JS null is not a reference to a non-existing object, but an object of itself Undefined: Is also an object of it\u2019s own, and its assigned to variables which have been declared but not assigned, we can also explicitly assign it, but that\u2019s not good practice since that a job for null. null acts like a zero when used in operations. i.e. null - 5 == -5 Objects Symbols: named objects The typeof operator: > let x = 5 > typeof x; // as an operator > typeof(x); // as a function typeof(null) returns \u201cobject\u201d, This is an officially recognized error of JS, kept for compatibility. null is not an object but a special type of it\u2019s own . Casting // casting > let x; > x = String(x) // To string > x = \"45\" / true // Numeric conversions happen automatically with operators > x = Number(x) // To Number // if one of the operands on + is a string, it will concatenate it > \"45\" + 1 // 451 > x = Boolean(\"0\"); // true // casting for booleans, values which are intuitively empty(\"\", null, undefined, NaN) // get evaluated to false. note \"0\" and \" \" are evaluated to true Numeric conversion rules: Value Becomes.. undefined NaN null 0 true and false 1 and 0 string Whitespaces from the start and end are removed. If the remaining string is empty, the result is 0. Otherwise, the number is \u201cread\u201d from the string. An error gives NaN \ud83d\udd25 Tip : We can use the unary + to cast to Number. let x = \"45\"; typeof +x; // Number +true // 1 // It doesn't do anything if the operand is not a Number // weird 4 + 5 + \"px\" // 9px \"px\" + 4 + 5 // px45 // operations run from left to rigth Unary operators have higher precedence than their binary counterparts. For more on operator precedence > https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence Chained assignments are evaluated from right to left The assignment operator returns the value that it just assigned. let a = 5; 5 + (a = a + 5); // returns 15 \ud83d\udce2 **The comma operator** // The comma operator evaluates all expressions and returns the last one let a = ( 2 + 4, 3 + 8); // a will equal 11 // This trick is used in many frameworks so look up // the comma has lower precedence than even the = for (a = 1, b = 3, c = a * b; a < 10; a++) { ... } // Really weird let a = 0; let b = \"0\"; Boolean(a) // false Boolean(b) // true a == b // true Strict equality === Strict equality operator, checks for equality without type conversion null > 0 // false null >= 0 // true null == 0 // false since equality doesn't cast null, like comparisions do null == undefined // true null === undefined // false \ud83d\udee0 **The very special OR || and AND &&** OR evaluates from left to right and returns the first truthy value, if none it returns the last AND also evaluates from left to right and returns the first faulty value, if none it returns the last result = value1 || value2 || value3 // result will be the first truthy value, if none it will be value3 // && has higher precedence than || let v1 = null; let v2 = \"\"; let result = v1 || v2 || \"no-name\"; // no-name let result = v1 && v2 && \"no-name\"; // null /* we can also use OR as an if statement due to them being short-circuit*/ true || expression; // won't get evaluated false || expression; // gets evaluated true && expression; // gets evaluated false && expression; // won't get evaluated The NOT ! operator ! converts to a Boolean and returns its inverse \ud83d\udee0 Double NOT ( !! ) is used to cast to Boolean. !!(\u201d0\u201d) // true \u26a0\ufe0f Inside a switch cases are matched with strict equality === switch(\"3\"){ case 3: // this will not become true since their types are different } Functions function smth(){ console.log(\"smth\") } // function declaration let smth = function(){ } // function expression let smth = () => {} // arrow functions,more concise than function expressions // we can specify parameters like function sayhello( person, message ) { console.log( person + \" : \" + message ) } // to specify a default value function sayHello( person, message = \"no message\") {} // we can assign the return of another function or expression as the default function sayHello ( person = expression , message = anotherFunction() ) /* we can use the fact that the default expression or function call only gets executed if the function is missing an argument */ // another way we can assign default values is with function sayHello(person, message){ person = person || \"no-name\"; message = message || \"no-message\"; } /* Functions can be copied, passed to other functions in which case they are called callbacks ... */ \u26a0\ufe0f In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter. In the example above, anotherFunction() is called every time showMessage() is called without the text parameter. This is in contrast to some other languages like Python, where any default parameters are evaluated only once during the initial interpretation. An empty or no-return returns undefined function a(){ return }; // a() -> undefined function b(){}; // b() -> undefined Modal function - pause the code execution until they finish eg. alert() \u2026 \u26a0\ufe0f **Function declaration VS Function expression:** Functions initiated with function expressions can only be used after they have been declared, unlike those with function declarations. In other words. **A Function Expression is created when the execution reaches it and is usable only from that moment.** \u26a0\ufe0f \u201cstrict\u201d mode alert \u26a0\ufe0f In strict mode functions will only be visible inside the block they were defined in.","title":"The Basics"},{"location":"The%20Basics/#the-basics","text":"If we give a src attribute inside our <script> tag, and at the same time define some code inside the <script> tags, the script inside will get ignored <script src=\"smt.js\"> console.log('hello'); // this code will get ignored </script> <aside> \ud83d\udca1 As a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files. The benefit of a separate file is that the browser will download it and store it in its cache. Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once. That reduces traffic and makes pages faster. </aside> ```jsx \"use strict\"; // we can do ^ this to switch the engine to modern mode // they must be at the top // we can also use them in functions // several language features like classes and modules enable strict mode by default we can declare multiple variables in one line let name=\"jim\", age=8n, height=45.4n; \u26a0\ufe0f **\u201cstrict\u201d mode alert** \ud83d\udd25 We could create variables without declaration merely through assignment, but this is not allowed in strict mode. Dynamically typed- there are datatypes but variables are not bound to them.","title":"The Basics"},{"location":"The%20Basics/#the-7-basic-datatypes","text":"Number: integers and floating point numbers, plus Special numeric values (Infinity, -Infinity, NaN ). Infinity is a result of division by 0. It\u2019s greater than any number. NaN is the result of a computational error. If there is a NaN inside a mathematical expression it will propagate through the whole expression. Doing math in JS is safe, i.e. it won\u2019t die with a fatal error, it will result in a NaN in the worst case Strings: can be surrounded with \u201c\u201d \u2018\u2019 or backticks(``). Booleans: either true or false Null: In JS null is not a reference to a non-existing object, but an object of itself Undefined: Is also an object of it\u2019s own, and its assigned to variables which have been declared but not assigned, we can also explicitly assign it, but that\u2019s not good practice since that a job for null. null acts like a zero when used in operations. i.e. null - 5 == -5 Objects Symbols: named objects","title":"The 7 basic Datatypes:"},{"location":"The%20Basics/#the-typeof-operator","text":"> let x = 5 > typeof x; // as an operator > typeof(x); // as a function typeof(null) returns \u201cobject\u201d, This is an officially recognized error of JS, kept for compatibility. null is not an object but a special type of it\u2019s own .","title":"The typeof operator:"},{"location":"The%20Basics/#casting","text":"// casting > let x; > x = String(x) // To string > x = \"45\" / true // Numeric conversions happen automatically with operators > x = Number(x) // To Number // if one of the operands on + is a string, it will concatenate it > \"45\" + 1 // 451 > x = Boolean(\"0\"); // true // casting for booleans, values which are intuitively empty(\"\", null, undefined, NaN) // get evaluated to false. note \"0\" and \" \" are evaluated to true Numeric conversion rules: Value Becomes.. undefined NaN null 0 true and false 1 and 0 string Whitespaces from the start and end are removed. If the remaining string is empty, the result is 0. Otherwise, the number is \u201cread\u201d from the string. An error gives NaN \ud83d\udd25 Tip : We can use the unary + to cast to Number. let x = \"45\"; typeof +x; // Number +true // 1 // It doesn't do anything if the operand is not a Number // weird 4 + 5 + \"px\" // 9px \"px\" + 4 + 5 // px45 // operations run from left to rigth Unary operators have higher precedence than their binary counterparts. For more on operator precedence > https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence Chained assignments are evaluated from right to left The assignment operator returns the value that it just assigned. let a = 5; 5 + (a = a + 5); // returns 15 \ud83d\udce2 **The comma operator** // The comma operator evaluates all expressions and returns the last one let a = ( 2 + 4, 3 + 8); // a will equal 11 // This trick is used in many frameworks so look up // the comma has lower precedence than even the = for (a = 1, b = 3, c = a * b; a < 10; a++) { ... } // Really weird let a = 0; let b = \"0\"; Boolean(a) // false Boolean(b) // true a == b // true Strict equality === Strict equality operator, checks for equality without type conversion null > 0 // false null >= 0 // true null == 0 // false since equality doesn't cast null, like comparisions do null == undefined // true null === undefined // false \ud83d\udee0 **The very special OR || and AND &&** OR evaluates from left to right and returns the first truthy value, if none it returns the last AND also evaluates from left to right and returns the first faulty value, if none it returns the last result = value1 || value2 || value3 // result will be the first truthy value, if none it will be value3 // && has higher precedence than || let v1 = null; let v2 = \"\"; let result = v1 || v2 || \"no-name\"; // no-name let result = v1 && v2 && \"no-name\"; // null /* we can also use OR as an if statement due to them being short-circuit*/ true || expression; // won't get evaluated false || expression; // gets evaluated true && expression; // gets evaluated false && expression; // won't get evaluated The NOT ! operator ! converts to a Boolean and returns its inverse \ud83d\udee0 Double NOT ( !! ) is used to cast to Boolean. !!(\u201d0\u201d) // true \u26a0\ufe0f Inside a switch cases are matched with strict equality === switch(\"3\"){ case 3: // this will not become true since their types are different }","title":"Casting"},{"location":"The%20Basics/#functions","text":"function smth(){ console.log(\"smth\") } // function declaration let smth = function(){ } // function expression let smth = () => {} // arrow functions,more concise than function expressions // we can specify parameters like function sayhello( person, message ) { console.log( person + \" : \" + message ) } // to specify a default value function sayHello( person, message = \"no message\") {} // we can assign the return of another function or expression as the default function sayHello ( person = expression , message = anotherFunction() ) /* we can use the fact that the default expression or function call only gets executed if the function is missing an argument */ // another way we can assign default values is with function sayHello(person, message){ person = person || \"no-name\"; message = message || \"no-message\"; } /* Functions can be copied, passed to other functions in which case they are called callbacks ... */ \u26a0\ufe0f In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter. In the example above, anotherFunction() is called every time showMessage() is called without the text parameter. This is in contrast to some other languages like Python, where any default parameters are evaluated only once during the initial interpretation. An empty or no-return returns undefined function a(){ return }; // a() -> undefined function b(){}; // b() -> undefined Modal function - pause the code execution until they finish eg. alert() \u2026 \u26a0\ufe0f **Function declaration VS Function expression:** Functions initiated with function expressions can only be used after they have been declared, unlike those with function declarations. In other words. **A Function Expression is created when the execution reaches it and is usable only from that moment.** \u26a0\ufe0f \u201cstrict\u201d mode alert \u26a0\ufe0f In strict mode functions will only be visible inside the block they were defined in.","title":"Functions"}]}