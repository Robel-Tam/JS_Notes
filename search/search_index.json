{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JS Notes","text":"<p>A Good place to look back at important JS concepts you might have forgotten.</p> <p>Notes for the most part are taken from and follow the outline of a great JS reference Javascript.info, but also include good to know concepts and examples that might have been left out, below is a list of the references used the most.</p>"},{"location":"#references","title":"References","text":"<ul> <li>Javascript.info</li> <li>ECMAScript specs</li> <li>Eloquent Javacript a modern introduction to programming</li> <li>Secrets of the Javascript ninja</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Feel free to submit a pull request, with anything from small fixes to new sections as this repo likely contains many typos, unclear abbreviations and so on.</p>"},{"location":"#outline","title":"Outline","text":"<ol> <li> <p>The basics</p> </li> <li> <p>Code Quality</p> </li> <li> <p>Objects</p> </li> <li> <p>Data Types</p> </li> <li> <p>Advanced working with functions</p> </li> <li> <p>Object properties configuration</p> </li> <li> <p>Prototypes and Inheritance</p> </li> </ol>"},{"location":"Advanced%20working%20with%20functions/","title":"Advanced working with functions","text":"<p>The number of times a recursive function calls itself is called a recursion depth.</p> <p>The maximum recursion depth is limited by engines. read about Tail call optimizations</p> <p>Recursive structures - Linked lists</p> <pre><code>let lList = {  // a linked list\n    value: 1,\n    next:{\n        value: 2,\n        next:{\n            value: 3,\n            next: null\n        }\n    }\n}\n\nfunction printList(list){  // recursive function for printing elements inside the lList\n    if(list.next == null) return list.value.toString();\n    return list.value.toString() + printList(list.next)\n}\n\nprintList(lList) // 123\n</code></pre>"},{"location":"Advanced%20working%20with%20functions/#rest-parameters","title":"Rest parameters","text":"<p>In JS it\u2019s ok to pass more arguments to a function that it needs, the function will simply ignore it.</p> <p>To store the passed arguments to an array we can use rest parameters ( \u2026rest ). The rest parameter must come at the end if other parameters exist.</p> <pre><code>function func( a, b, ...c)\n</code></pre> <p>arguments object also contains all arguments passed by index</p> <pre><code>function fun( a, b, c ) {\n    console.log(arguments);\n    console.log(arguments[1]);\n    console.log(arguments.length);\n}\n\nfun(1,2,3,4);\n/* output\n[Arguments] { '0': 1, '1': 2, '2': 3, '3': 4 }\n2\n4\n*/\n</code></pre> <p>The downside of the arguments object is that it\u2019s not an array, so we can\u2019t use array methods on it.</p> <p>Arrow functions don\u2019t have the arguments object, they will take it from an outer function if it exists</p>"},{"location":"Advanced%20working%20with%20functions/#spread-operator","title":"Spread operator \ud83c\udf1f","text":"<p>The syntax for the rest operator (\u2026arr) can also spread an iterable object in to a list of values.</p> <pre><code>let str = \"hello\"\nlet arr = [...str]  // [\"h\",\"e\",\"l\",\"l\",\"o\"]\n\n// we can use this operator to pass arrays to functions expecting list of arguments\narr = [ 1,2,3,4,5 ]\nMath.max(...arr) // 5\n\n// we can also pass multiple iterables, and we can also combine them with non iterables\narr2 = [ 6,7,8,9 ]\nMath.max(...arr, 34, ...arr2, 1) // 34\n\n// we can use spread operators to merge arrays\narr2  = [ ...arr2, ...arr1 ]\n</code></pre> <p>Unlike the Array.from() method, the spread operator only operates on iterables and not array-likes, so Array.from() is a more universal way to convert stuff into arrays</p>"},{"location":"Advanced%20working%20with%20functions/#closures","title":"Closures","text":"<p>Are functions that remember their outer variables and can access them. All JS functions are naturally closures.</p>"},{"location":"Advanced%20working%20with%20functions/#lexical-environment","title":"Lexical Environment","text":"<p>A lexical environment is a specification (internal / hidden ) object associated with every function call / block / script. i.e. every running function/ block / script have their own.</p> <p>A lexical environment has two parts, environment record and reference to an outer lexical environment. </p> <p>An environment record - holds all the local variables as it\u2019s properties, and the value of this. therefore a variable is just a property of the internal object- environment record.</p> <pre><code>// A visualization for lexical environments\nLexical_Environment{\n    Environment_Record: {  /*var1 : smth, ... */ },\n    Outer: /*null in the case of a global lexical env */\n}\n\nlet phrase;  // { Environment_Record:{ phrase: undefined }, Outer: null }\nphrase = \"hello\"; // { Environment_Record:{phrase: \"hello\"}, Outer: null }\nphrase = \"bye\" ;  // {Environment_Record:{pharse: \"bye\"}, Outer: null }\n</code></pre> <p>Function declarations get initialized when the lexical environments that holds them gets created, unlike those with let , that get initialized when execution reaches it. That\u2019s why we can call functions before their declaration. All functions on birth get a hidden property [[Environment]] which contains a reference to the lexical environment of their creation. functions remember where they were created using this hidden property.</p> <pre><code>// A visulization\n/* Execution starts -&gt; { \n            Env_record:{\n                    greet: function\n            },\n            Outer: null  } */\nlet name = \"Jhon\"        /* -&gt; {\n             Env_record:{\n                        greet: function,\n                        name: \"Jhon\"\n                },\n                Outer: null   } */\nfunction greet(title){  // [[Environment]] -&gt; global lexical environment\n        console.log(\"hello \" + title + \" \" + name);\n}\n</code></pre> <p>Nested lexical environments : Let\u2019s call function greet</p> <pre><code>greet(\"Mister\") // hello Mister Jhon\n// The execution environment created for this function call is\n/* [[Environment]] -&gt; {\n Env_record:{\n            title: \"Mister\",\n    },\n    Outer: /* A referance to the outer Lexical env with the value for name */\n} \n*/\n</code></pre> <p>When the code wants to access a variable, it\u2019s lexical environment is scanned first, if the variable is not found then the outer lexical environments are scanned progressively until it reaches the global lexical environment. That\u2019s how local variables override outer ones.</p>  \u26a0\ufe0f **Strict mode alert**                                                                                                                                     If a variable is not found in any of the lexical environments, its an error in strict mode. But if we are not in strict mode, An assignment to an undefined variable creates a new global variable   <pre><code>\nfunction f(){ b = 5 };\nconsole.log(b) // 5 in non-strict mode\n// if we are in strict mode -This will throw a ReferanceError\n// if we are not, variable b will get created in the global context\n</code></pre>"},{"location":"Advanced%20working%20with%20functions/#nested-functions","title":"Nested Functions","text":"<p>We can use them to organize code</p> <pre><code>function printSquare(n){\n    function square(n) { \n            return n * n;\n    }\n    console.log(square(n));\n}\n</code></pre> <p>We can use them inside constructors to create methods</p> <pre><code>function User(name){\n    this.sayName = function(){\n        console.log(\"My name is \" + name;\n    }\n}\n</code></pre> <p>We can return the functions themselves</p> <pre><code>function makeCounter(){\n        let count = 0;\n        return function(){\n                return count++;\n        }\n}\nlet c = makeCounter();\nlet d = makeCounter();\nc() // 0\nc() // 1\nd() // 0\n</code></pre> <p>When the first c() gets called, this happens</p> <pre><code>c() [[Environment]] -&gt; {  \n    Env_record:{},\n            Outer: -&gt; {\n                     Env_record:{\n                                count: 0,\n                        },\n                        Outer: -&gt; // global lexical env\n                    } \n                }\n         } \n</code></pre> <p>Code Blocks, loops and IIFE</p> <p>Lexical environments can exist for any code block. A lexical environment is created when a block runs and contains block local variables</p> <pre><code>if(true){\n    let v = 5;\n}\nv // ReferanceError\n// v can't be accessed from outside of the if blocks lexical environment\n</code></pre> <p>Inside loops, every loop will have it\u2019s own lexical environment</p> <p>We can use a bare code block {} to isolate variables into a local scope.</p> <p>In a web browser all scripts except the ones with type=\u201dmodule\u201d share the same global area, So if we create a global variable in one script it will become available to the others, this may cause conflicts. But we can isolate each script by putting it inside its own block</p> <p>There used to be no block-level lexical environment in JS, so a work around called IIFE ( immediately invoked function expressions ) was used.</p> <pre><code>(function (){ /* script */ })()\n// other ways\n( function(){ /* script */ }() )\n!function(){ /* script */ )()\n+function(){ /* script */ )()\n</code></pre> <p>we use the parenthesis to say that the function is created in the context of another expression.</p>"},{"location":"Advanced%20working%20with%20functions/#the-old-var","title":"The old var","text":"<p>variables declared with var also have lexical environments that are bound to function scopes.</p> <pre><code>function fun(){\n    let a = 1;\n    var b = 2;\n}\nalert(a) // ReferanceError\nalert(b) // ReferanceError  because vars are also bound to function scopes\n</code></pre>  \ud83d\udce2  But unlike those declared with **let** and **const** they are not bound to block scopes.   <pre><code>{\n    let a = 1;\n    var b = 2;\n}\n\nalert(a) // ReferanceError\nalert(b) // 2     var ignores code blocks\n\n// inside if blocks\nif(true){\n    var test = 4;\n}\nalert(test) // 4\n\n// inside loops\nfor( var i = 0; i &lt; 10; i++);\nalert(i) // 9\n</code></pre>  \ud83d\udce2 **var** declarations get hoisted i.e. they get processed as soon as the script ( for global L.E ) or the function they are in gets executed. In other words their declaration gets moved up to the function or the script. Therefore we can use them before they get declared   <pre><code>function greet(){\n    str = \"hello\";\n    if(false){ \n        var str\n    }\n    console.log(str);\n}\n\ngreet() // hello\n</code></pre> <p>Declarations are hoisted but assignments are not</p> <pre><code>function greet(){\n    console.log(str);\n    var str = \"hello\"\n}\ngreet() // undefined\n</code></pre>"},{"location":"Advanced%20working%20with%20functions/#the-global-object","title":"The global object","text":"<p>Provides variables and functions that are available anywhere. Mostly the ones that are built into the language or the environment. </p> <p>In the browser it\u2019s name window, global in node. But globalThis has been added to the language as a standardized name for the global object.</p> <p>we can access members of the global object directly but it\u2019s good practice to refer to them through the global object. i.e. globalThis.x instead of x</p> <p>In-browser unless we\u2019re using modules, variables declared with var and global functions get added to the global object.</p> <p>We can use the global object to test for support of modern language features</p>"},{"location":"Advanced%20working%20with%20functions/#the-function-object","title":"The function object","text":"<p>Functions in JS are objects. So they have some usable properties of their own</p> <pre><code>function f(){}\nReflect.ownKeys(f) // [ 'length', 'name', 'arguments', 'caller', 'prototype' ]\n\nReflect.ownKeys((a, b) =&gt; {}) // [ 'length', 'name' ]\n</code></pre> <p>func.name :  returns a read only name of the function</p> <pre><code>function sayHi() {}\nsayHi.name // 'sayHi'\n\nlet sayHi() = function(){}\nsayHi.name // 'sayHi'\n\nlet user = { sayHi(){} }\nuser.sayHi.name // 'sayHi'\n</code></pre> <p>func.length : returns the number of arguments a function accepts</p> <pre><code>function s( a, b, ...c){}\ns.length // 2  rest parameters are not counted \n</code></pre> <p>custom properties</p> <p>we can add properties of our own to functions.</p> <pre><code>// lets add a count property which stores the number of calls made to func\nfunction func(){\n        func.count++;\n        console.log(func.count)\n}\n\nfunc.count = 0;\nfunc() // 1\nfunc() // 2\nfunc() // 3\n</code></pre> <p>Closures can sometimes be replaced with function properties</p> <pre><code>// let's redo the makeCounter function with a custom property\nfunction makeCounter(){\n        function counter(){\n            return counter.count++;\n        }\n        counter.count = 0 ;\n        reutrn counter;\n}\n\nlet c = makeCounter();\nc() // 0\nc() // 1\nc.count = 40;\nc() // 40\n\n// In this case we can modify the counter\n</code></pre>"},{"location":"Advanced%20working%20with%20functions/#named-function-expressions-nfe","title":"Named function expressions ( NFE )","text":"<p>NFE is when we give names to the function on the right side of the function in our functional expressions.</p> <pre><code>// normal functional expression\nlet func = function() { }\n\n// NFE\nlet func = function sayHi(){ } \n// NFE allows us to reference the function from within\n// the identifier sayHi isn't visible outside the function\n</code></pre> <p>We use NFE when we want to reference the function from within the function.</p> <pre><code>let sayHi = function func(ph){\n                                if(ph) console.log(ph);\n                                else func(\"hello\");\n}\n\n// We could have done \nlet sayHi = function func(ph){\n                                if(ph) console.log(ph);\n                                else sayHi(ph)\n}\n// but the above code will stop working if we change the value of sayHi\nlet anotherFunc = sayHi;\nsayHi = null;\nanotherFunc(\"d\") // d\nanotherFunc() // Error sayHi is not a function\n// This happens because the identifier sayHi was taken from the outer L-Env\n\n// This can't be done with function declarations\n</code></pre>  \ud83d\udce2 **Question**                                                                                                                                                     Write a function sum that would work like this:                                                                                     sum(1)(2) == 3; // 1 + 2                                                                                                        sum(1)(2)(3) == 6; // 1 + 2 + 3                                                                                                       sum(5)(-1)(2) == 6"},{"location":"Advanced%20working%20with%20functions/#new-function-syntax","title":"new Function() syntax","text":"<pre><code>let func = new Function ([arg1, arg2, ...argN], functionBody);\n</code></pre> <p>This syntax creates a function with arguments arg1 - argN with functionBody </p> <pre><code>let func = new Function(functionBody) // a function without arguments\n</code></pre> <p>Functions created with new Function() have an [[ Environment ]] referencing to the global Lex-Environment. This helps us to hide our local variables from them and to avoid running into problems when using minifiers.</p> <p>The arguments can also be given in a comma separated list.</p> <pre><code>new Function(\"a\", \"b\", \"c\", \"alert(a)\" );\nnew Function(\"a,b\", \"c\", \"alert(a)\");\nnew Function(\"a,b,c\", \"alert(a)\" ) ;\n// all work the same\n</code></pre>"},{"location":"Advanced%20working%20with%20functions/#scheduling-settimeout-setinterval","title":"Scheduling : setTimeout &amp; setInterval","text":"<p>These methods are not part of the JS specification. But most environments have an internal scheduler that provides these methods.</p> <p>setTimeout - causes a function or piece of code to run once after a period of time</p> <p>setInterval - causes a function to run regularly with the given interval</p> <pre><code>// setTimeout( func, [delay] , [arg1], [arg2], [argn] );  delay in ms\nfunction sayHi(name){\n        console.log(`Hi ${name}`\n}\n\nlet timerId = setTimeout(sayHi, 9000, \"Smith\"); \n// after 9 seconds =&gt; Hi Smith\n// a call to setTimeout returns a timerId we can use this to cancel it\n\n// setInterval(func, [delay], [arg1], [arg2], [argn] );\nlet timerId2 = setInterval(sayHi, 2000, \"Jack\" );\n// Hi Jack will be displayed every 2 seconds\n</code></pre> <p>canceling with clearTimeout and clearInterval</p> <pre><code>clearTimeout( timerId )\nclearInterval( timerId2 )\n</code></pre>"},{"location":"Advanced%20working%20with%20functions/#recursive-settimeout","title":"Recursive setTimeout","text":"<p>There are two ways of running something regularly, using setInterval and with recursively calling setTimeout.</p> <pre><code>let clock = setTimeout( function f(){\n            console.log(\"Tick Tok\");\n            setTimeout( f, 1000);\n        }, 1000 );\n</code></pre> <p>This is a more flexible way because we can manipulate the delays.</p> <p>The recursive setTimout unlike setInterval guarantees the fixed delay ??</p> <p>when a function is passed to setTimeout or setInterval, an internal reference to it is created and saved in the scheduler. This prevents the function from being garbage collected. But it also saved the outer lexical environment of the function, This might take much more memory than the function itself so when we don't need the scheduled function anymore it's better to cancel it. we can do that with clearTimeout and clearInterval</p>"},{"location":"Advanced%20working%20with%20functions/#decorators-and-forwarding-callapply","title":"Decorators and forwarding, call/apply","text":"<p>Let's see how cool JS functions can be</p>"},{"location":"Advanced%20working%20with%20functions/#transparent-caching","title":"Transparent caching","text":"<p>If we want to cache(remember) the results for different arguments of a CPU intensive function we can create a wrapper function like so.</p> <pre><code>function slow(x){\n    // slow calculations\n    return x;\n}\n\nfunction cachingDecorator(func){\n    let cache = new Map();\n    return function(x){\n        if(cache.has(x)){\n            return cache.get(x);\n        }\n        let result = func(x);\n        cache.add(x, result;\n        return result;\n    }\n}\n\nlet slowFunc = cachingDecorator(slow);\nslow(1) // got computed and cached\nslow(1) // returned from cache\n</code></pre> <p>This code will fail if we try to pass Object methods to the wrapper and access properties that belong to the \"this\" context of that object.</p> <pre><code>let obj = {\n    method(){\n        return 1;\n    }\n    slow(x){\n        // kicka$$ code\n        return x + this.method();\n    }\n}\n\nlet obj.slow = cachingDecorator(obj.slow);\n// this will fail because this.method() will be undefined\n</code></pre> <p>To overcome this problem we can use function.call() to pass the context as well. func.call() allows us to explicitly pass \"this\"</p> <pre><code>func.call( context, arg1, arg2, ... ); // syntax for .call()\n</code></pre> <pre><code>function greet(){\n    console.log(`Hello my name is ${this.name}`);\n}\n\nlet jack = {name: \"Jack Taylor\"}\nlet bob = {name: \"Bob Smith\"}\n\ngreet.call(jack)// Hello my name is Jack Taylor\ngreet.call(bob) // Hello my name is Bob Smith\n</code></pre> <p>So we can simply fix our wrapper function by changing the assignment to</p> <pre><code>let result = func.call(this, x);\n</code></pre> <p>We can also pass the context to a function call using func.apply( context, args) where args is an array like, we can use this when we want to pass an array like containing the multiple arguments for the function we are about to call.</p> <pre><code>let args = [1, \"2\", 3];\n\nfunc.apply(context, args);\n// the same effect can be acheived with\nfunc.call(context, ...args);\n\n// But func.apply() can get optimized better by engines\n</code></pre> <p>func.apply() doesn't accept iterables only array likes.</p> \u26a0 **read about method borrowing** spy decorator \u2753 **Good Question** Create a decorator delay(f, ms) that delays each call of f by ms milliseconds. page# 383 <pre>\n<code>\nfunction print(a) { console.log(a) }\nlet f3000 = delay(print, 3000);\nf3000(\"hello\") // prints hello after 3 seconds\n</code>\n</pre> Topics I have to look into again <ul> <li>Function binding</li> <li>Currying and partials</li> <li>Arrow functions revisited</li> <li>Every thing from page 355 onward</li> </ul>"},{"location":"Array%20methods%20cheat-sheet/","title":"Array methods cheat-sheet","text":"<p>A cheat sheet of array methods:</p> <p>To add/remove elements: - push(...items) \u2013 adds items to the end, - pop() \u2013 extracts an item from the end, - shift() \u2013 extracts an item from the beginning, - unshift(...items) \u2013 adds items to the beginning. - splice(pos, deleteCount, ...items) \u2013 at index pos delete deleteCount elements and insert items .       slice(start, end) \u2013 creates a new array, copies elements from position start till             end (not inclusive) into it.       concat(...items) \u2013 returns a new array: copies all members of the current one and             adds items to it. If any of items is an array, then its elements are taken. To search among elements:       indexOf/lastIndexOf(item, pos) \u2013 look for item starting from position pos ,             return the index or -1 if not found.       includes(value) \u2013 returns true if the array has value , otherwise false .       find/filter(func) \u2013 filter elements through the function, return first/all values that              make it return true .       findIndex is like find , but returns the index instead of a value. To iterate over elements:      forEach(func) \u2013 calls func for every element, does not return anything. To transform the array:      map(func) \u2013 creates a new array from results of calling func for every element.      sort(func) \u2013 sorts the array in-place, then returns it.      reverse() \u2013 reverses the array in-place, then returns it.      split/join \u2013 convert a string to array and back.      reduce(func, initial) \u2013 calculate a single value over the array by calling func              for each element and passing an intermediate result between the calls. Additionally:    Array.isArray(arr) checks arr for being an array. Please note that methods sort , reverse and splice modify the array itsel</p>"},{"location":"Code%20Quality/","title":"Code Quality","text":"<p>We can write strings on multiple lines by adding \\ to the end of every line, this won\u2019t include the newline to the string.</p> <p>If we want to write multiple lines ( including the newline character) to a string we can include them inside backticks ( `` )</p> <pre><code>let str = \" hello world \\\nhow are you\";\nconsole.log(str); // hello world how are you\nstr = ` hello\nworld`; // hello\\nworld\n</code></pre> <p>Avoid nesting levels</p> <pre><code>// instead of \nfor( i=0; i&lt;5; i++){\n    if(cond){ /*smth*/ }\n} \n// we can write\nfor( i =0 ; i&lt;5; i++){\n    if(!cond) continue;\n    // smth\n}\n</code></pre>"},{"location":"Code%20Quality/#polyfills-and-babel","title":"polyfills and babel ?","text":"<p>transpiler</p>"},{"location":"Data%20Types/","title":"Data Types","text":"<p>Four of the primitive types namely string, number, symbol, Boolean can behave like objects in that the dot operator can be used on them to get some of their \u201cproperties\u201d and methods. this is due to the use of \u201cwrapper objects\u201d. </p> <p>The four wrapper objects are String, Number, Boolean, Symbol. It\u2019s bad practice to call these constructors with the new keyword.</p> <pre><code>let a = Number(\"123\");\ntypeof a // number\nlet b = new Number(\"123\");\ntypeof b // object\n</code></pre>  \u2753 Good question   <pre><code>// what will happen ?\nlet str = \"hello\";\nstr.test = 5; // (^)\nconsole.log(str.test); // (*)\n\n//Answer\n/* If we are not in strict mode, line (^) will create a String wrapper object and then\n * it creates the property test and gives it 5. then on line (*) it will return\n * undefined, since the previous wrapper object got removed. \n * If it's in strict mode in will return an error\n*/   \n</code></pre>"},{"location":"Data%20Types/#numbers","title":"Numbers","text":"<p>all numbers are stored in 64 bit format, also called double precision floating point numbers</p> <p>we can use \u2018e\u2019 to write numbers in short hand ( 7e4 = 70000, 23e-1 = 2.3 )</p> <p>Hexadecimals - prefix 0x</p> <p>Binaries- prefix - 0b</p> <p>Octal- prefix -0o</p> <p>Number.toString(base): returns the string representation on the number, in the given base, if no base is given 10 is used as a default</p> <pre><code>let num = 255;\nnum.toString(2) // 11111111\nnum.toString(16) // ff\n// base 36- is the maximum 0-9 A-Z\n</code></pre>  \u26a0\ufe0f two dots ( 34..toString())   <pre><code>// if we want to call methods directly on the number literals we can use\n7..toString(2);\n(7).toString(2); // this is also possible\n/* If we were to use only one dot, it will imply that there is a decimal part after\n   it, but the other dot resolves that issue, */\n6e3..toString(); // ERROR ! 6e3.toString()\n0x3a2..toString(); // ERROR !  0x3a2.toString()\n</code></pre> <p>methods to modify numbers</p> <pre><code>Math.floor(1.6) // 1\nMath.ceil(1.2) // 2\nMath.round(1.4) // 1\nMath.trunc(2.12) // 2  removes the decimal part\n\n// to round a number to the n-th digit after the decimal\nlet num = 1.2345;  // to round this to the 2nd digit\n// 1\nMath.floor(num * 100)/ 100  // 1.23\n// 2\nnum.toFixed(2)  // '1.23'  string\n\n</code></pre> <p>Imprecise calculations:</p> <p>From the 64 bits, used to represent numbers, 52 are used to store the digits, 11 are used to store the position of the decimal and 1 is used to store the sign. If a number is to big to be stored in this, it will overflow and resolve to infinity.</p> <pre><code>1e500; // infinity\n0.1 + 0.2 // 0.30000000000000004\n0.1.toFixed(25); // '0.1000000000000000055511151'\n</code></pre> <p>Decimals that don\u2019t reduce to ( x/ 2), will be endless binary fractions, so there\u2019s no way to store them exactly, but JS rounds them to the nearest possible number, but these precision losses still exist.</p> <p>Infinity and NaN</p> <p>-Infinity and Infinity are special values which are smaller than or greater than any number.</p> <p>-NaN represents and error</p> <p>isNaN(arg) : - converts it\u2019s argument into a Number, and checks to see if it\u2019s NaN</p> <pre><code>NaN == NaN // false\n// NaN can't equal any number or even it self\nInfinity == Infinity // true\n</code></pre> <p>isFinite(arg) : -  returns true if the arg, is not NaN, Infinity or -Infinity</p> <pre><code>isFinite(\"123\") // true\nisFinite(\"str\") // false\nisFinite(1) // true\n// isFinite() can be used to check if a string holds a number\nisFinite(\"+3\") // true\n// !!! an empty or space only string resolves to 0 when casted to number\nisFinite(\" \") // true  !!!\n</code></pre> <p>Object.is( arg1, arg2) : - is the same as arg1 === arg2, except in these two cases</p> <ol> <li>it works with NaN </li> </ol> <pre><code>Object.is(NaN, NaN) // true\n</code></pre> <ol> <li>Values 0 and -0 are different. Object.is(0, -0) \u2192 false</li> </ol> <p>parseInt(str, base), and parseFloat(str)</p> <pre><code>parseInt('45px') // 45\nparseInt(\"3 Inch\") // 3\nparseInt(\"4.7\") // 4\n\nparseFloat(\"45.4em\") // 45.4\nparseFloat(\"4.3.2\") // 4.3 \n\n// Fails\nparseInt(\"a45\")  // if the first character is not a digit\nparseInt(\"abc\") // NaN\n\n// base given\nparseInt(\"ff\", 16) // 255\n\n/* this is a great way to check if a number belongs to a base*/\nisFinite(\"ii\", 16) // false\nisFinite(\"ii\", 36)  // true\n</code></pre> <p>Math.random() : - returns a random number \u2265 0 and &lt; 1</p> <p>Math.max(a, b, c, \u2026) and Math.min(a,b,c, \u2026)</p>  \u2753 Good Question   <pre><code>/* why is 6.35.toFixed(1) == 6.3 */\n// toFixed() works just like round() when rounding to a given precision\n// the problem happened because of the way 6.35 is represted\n6.35.toFixed(20) // '6.34999999999999964473'\n// precision loss made 6.35 smaller\n// a better way to do it would be to \nMath.round(6.35 * 10) / 10\n</code></pre>"},{"location":"Data%20Types/#strings","title":"Strings","text":"<p>The internal format for strings is UTF-16 and is not tied to page\u2019s encoding.</p> <p>Back ticks (``) allow for string interpolation, tagged templates and string that span multiple lines.</p>  \ud83d\udd25 Tagged strings [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals)   <p>Only quotes that are the same as the enclosing quotes will be escaped</p> <p>strings have a .length property</p> <p>Accessing characters: we can use [] operator or .charAt()</p> <pre><code>let str = \"hello\";\nstr[0] // s\nstr.charAt(0) // s\nstr[100] // undefined\nstr.charAt(100) // ''  -&gt; empty string\n</code></pre>  \u26a1 for( .. of .. ) loop can be used on string because they are iterable   <pre><code>let str = \"ola\";\nfor ( let c of str) ; \n</code></pre> <p>String are immutable</p> <pre><code>let str = \"selam\";\nstr[2] = 'd' // won't work, but it won't stop execution\nstr // selam\n</code></pre> <p>toUpperCase() and toLowerCase()</p>"},{"location":"Data%20Types/#searching-for-a-substring","title":"searching for a substring","text":"<p>str.indexOf(substr, index)</p> <pre><code>let str = \"search for sub string\";\nstr.indexOf(\"search\") // 0\nstr.indexOf(\"s\") // 0\nstr.indexOf(\"s\", 1) // 11\n// if it doesn't find it\nstr.indexOf(\"max\") // -1\nstr.indexOf(\"s\", 100) // -1\n</code></pre>  \u2753 Good Question   <pre><code>/* count occurances of a substring in a string */\nlet str = \"JavaScript is a very cool language\";\nlet target = \"a\";\nlet cnt = 0, pos = 0;\n\nwhile(true){\n if(str.indexOf(target, pos++) != -1) {cnt++}\n else {break}\n</code></pre> <p>str.lastIndexOf(substr, index) :-  searches starting from the end of string to the start</p> <p>str.includes(substr, index) : - returns true if str includes substr</p> <p>str.startsWith(prefix) : - returns true if str starts with prefix</p> <p>str.endsWith(suffix) : - </p>"},{"location":"Data%20Types/#getting-a-substring","title":"Getting a substring","text":"<p>str.slice(start, end) :- returns a in between start index and end index, including the start and excluding the end</p> <pre><code>let str = \"string\"\nstr.slice(1, 3) // tr\n// if the end is not given it's defaulted to legth of the string\nstr.slice(2) // ring\nstr.slice() // string\n// negative values are also allowed\nstr.slice(-4, -1) // rin\n</code></pre> <p>str.substring(start, [ end ]) :- is the same as slice, but allows the start to be greater than end, and it doesn\u2019t support negative arguments, it will just treat them as 0.</p> <p>str.substr(start, [ length ]) :- returns part of the string starting from the start upto the given length. The start can be negative</p> <pre><code>let str = \"string\"\nstr.substring(2, 4) // ri\nstr.substring(4, 2) // ri\nstr.substring(-2 ) // string\n\n// substr\nstr.substr(2, 3) // rin\nstr.substr(3)    // ing\nstr.substr(-4, 2) // ri\n</code></pre>"},{"location":"Data%20Types/#string-comparison","title":"string comparison","text":"<p>methods codePointAt(index) and String.fromCodePoint(point)</p> <pre><code>\"Z\".codePointAt(0) // 90  returns the code for the character at position 0\n\"a\".codePointAt(0) // 97\n\nString.fromCodePoint(90) // Z returns the character at the given code point\nString.fromCodePoint(97) // a\n</code></pre> <p>In-order to do correct string comparisons in different languages, we can use the localeCompare(str2) method from the Intl.JS library.</p> <pre><code>let str1 = \"apple\"\nlet str2 = \"ball\"\n\nstr1.localeCompare(str2) // -1 because it's less \nstr2.localeCompare(str1) // 1\nstr1.localeCompare(str1) // 0\n</code></pre>  \ud83d\udcdd **Surrogate pairs** - All frequently used Unicode characters have 2byte codes, but some have two pairs of those. these characters have a length of two.    \ud83d\udcdd **Diacritical marks and normalization -**  some letters have marks above / below them we can do this by adding the marks Unicode after our symbols. eg. \u2018S\\u0307\u2019 is \u1e60 and 'S\\u0307\\u0323\u2019 is \u1e68. these bring an interesting problem in that similar looking characters will can get represented by different codes, to overcome this we can use the **normalize()** method. it will bring these characters to a common normal form"},{"location":"Data%20Types/#arrays","title":"Arrays","text":"<p>Arrays are objects that can store different types of data, and they can grow dynamically, the elements of an array are stored in contiguous memory area.</p> <pre><code>let A = new Array();\nlet B = [ \"jhon\", 4 , 8.3, function() {console.log(\"hello\")} ]\nB.length // 4\nB[4] = \"abc\";\nB.length // 5\nB[3]() // hello\n</code></pre> <p>In JS arrays support both stacks ( LIFO ) and queues ( FIFO ), this is also called deque</p> <p>Methods .push() and .pop(): work with the end of an array, push returns the size of the new array</p> <p>Methods .shift() and .unshift() </p> <p>shift() works just like pop() but it operates on the first element</p> <p>unshift() works just like push() but to the beginning of the array, unshift can take multiple arguments, it returns the size of the new array</p> <p>Methods push and pop are much faster than shift and unshift, because they don\u2019t have to reorder the elements after they are done.</p>  \ud83d\udcdd Arrays are optimized to work fast, but if we start treating them like objects we will lose the benefits of the optimizations. The ways we can misuse Arrays are                                                                               ~                     By adding non-numeric properties                                                                              ~                     Creating gaps in between the indexes ar[0] ar[1000] nothing in between                    ~                      Filling the array in the reverse order"},{"location":"Data%20Types/#looping-through-arrays","title":"Looping through arrays:","text":"<pre><code>let arr = [ \"name\", \"age\", \"school\" ]\n// using a traditional for loop\nfor(let i =0; i &lt; arr.length ; i ++ ) arr[ i] ;\n// using for .. of loop\nfor( let val of arr) var\n// not recommended ! using for ... in loops\n// 10 - 100 times slower than for ... of\nfor( let val in arr) arr[val]\n</code></pre>  \u2622\ufe0f The **length** property : - Automatically updates when the array is modified. length is not the number of values in the array but the largest numeric index + 1.                                                        **The length property is writable:** We can change the value of length. if we increase it nothing special will happen, but if we decrease it, the array will be truncated   <pre><code>// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nlet arr = [ 1, 2,3 4,5 ]\narr.length = 2;\narr // [ 1, 2 ]\narr.length = 4; \narr // [ 1, 2, undefined, undefined]\n// therefore the simplest way to clear an array is arr.length = 0;\n</code></pre>  \u26a0\ufe0f Careful when using new Array(). If we call the constructor with one numeric argument, it will take create an array with that size   <pre><code>let a = new Array(3);\na[1] // undefined\na.length // 3\n</code></pre> <p>Multidimensional arrays</p> <pre><code>let a = [\n        [ 1, 2, 3],\n        [ 4, 5, 6],\n        [ 7, 8, 9]\n];\na[1][2] // 6\n</code></pre> <p>Arrays\u2019 toString() : returns a comma separated list of the elements</p>  \u2699 array.splice( from [ , count, elemt1, elment2, \u2026] ) : returns the array of removed elements. Starting from \u2018from\u2019 remove \u2018count\u2019 elements and replace them with elemts   <pre><code>let arr1 = [1, 2, 3, 4, 5, 6]\narr1.splice( 1, 2 ) // =&gt;  [ 4, 5, 6]\narr1 // [ 1, 2, 3 ]\n\narr1 = [1, 2, 3, 4, 5, 6]\narr1.splice(0, 2, \"hello\" ,\"world\"); // [ 1, 2 ]\narr1 // [ \"hello\", \"world\", 3, 4, 5, 6 ]\n\n// we can use splice to insert with out deleting by setting count to 0\narr1.splice( 1, 0, \"great\" ) // []\narr1 // [\"hello\", \"great\", \"world\", 3, 4, 5, 6 ]\n\n// negative indexes are allowed\narr1.splice( -4, 4) // [ 3, 4, 5, 6 ] \narr1 // [ \"hello\", \"great\", \"world\" ]\n</code></pre>  \u2699 Method **slice( start , end)**, works on arrays and strings and returns a subarray from index start to end or a substring if it\u2019s called on a string   <pre><code>let str = \"hello\"\nlet arr = ['h', 'e', 'l', 'l', 'o' ]\n\nstr.slice(1, 4) // 'ell'\narr.slice(1, 4) // [ 'e', 'l', 'l' ]\n\nstr.slice(2) // 'llo'\n</code></pre>  \u2699 Method array.concat( arg1, arg2, \u2026) : returns array concatenated with the arguments. If the argument is has a Symbol.isConcatSpreadable it will get spreaded and concatenated to array. if not it will be appended to the end of array as it is   <pre><code>let arr = [ 1,2,3,4 ]\narr.concat(\"yee\", \"haa\") // [ 1,2,3,4,\"yee\", \"haa\" ]\narr // [ 1,2,3,4 ]  concat doesn't alter arr\nlet arr2 = [ \"ping\", \"pong\" ]\narr.concat(\"I\", \"love\", arr2 ) // [ 1,2,3,4,\"I\", \"Love\", \"ping\", \"pong\" ]\n\nlet obj = {\n    0 : 'yee',\n    1 : 'ha' , \n    [Symbol.isConcatSpreadable] : true,\n}\n\narr.concat(obj) // [ 1,2,3,4,'yee', 'ha']\n\n\n</code></pre>  \u2699 Method array.forEach(func) : allows you to run a function on each element of the array. functions called inside forEach get passed the arguments ( item, index, array )   <pre><code>&gt; let arr = [ 1,2,3 ]\n&gt; arr.forEach(console.log());\n1 0 [ 1, 2, 3, 4, 5, 6 ]\n2 1 [ 1, 2, 3, 4, 5, 6 ]\n3 2 [ 1, 2, 3, 4, 5, 6 ]\n&gt;\n&gt; let func = (item, index, array) =&gt; \n              console.log(`item : ${item}, index : ${index}, array: ${array}`) \n&gt; arr.forEach(func);\nitem: 1, index: 0, array: 1,2,3,4,,5,6\nitem: 2, index: 1, array: 1,2,3,4,,5,6\nitem: 3, index: 2, array: 1,2,3,4,,5,6\n</code></pre> <p>Searching in an array</p>  \u2699 methods arr.**indexOf(item, from),** arr.**lastIndexOf(item, from),** arr.**includes(item, from)** do the same things as their string counter-parts, they use the === comparison. ****   <pre><code>// one notable difference is\nconst arr = [NaN];\narr.indexOf(NaN) // -1\narr.includes(NaN) // true\n</code></pre>  \u2699 method arr.**find( function )** :- if function returns true, iteration is stopped and the item is returned, if false undefined is returned.   <pre><code>const arr = [\n        { id: 1, age: 34 },\n        { id: 2, age: 23 },\n        { id: 3, age: 34 },\n]\n// to find element with id 2\narr.find( (item, index, array) =&gt; item.id == 2  );\n// { id: 2, age: 23 } \n\n// to find element with age 23\narr.find( item =&gt; item.age == 23 )\n// { id: 2, age: 23 }\n</code></pre>  \u2699 method arr.**findIndex( function )** :- is the same as find() but, it returns the index if its found and -1 if not   <pre><code>&gt; let arr2 = [ 1,2,3,4,5 ]\n&gt; arr2.findIndex( item =&gt; item == 3 );\n2\n</code></pre>  \u2699 method **arr.filter( function ) :-** is also the same as find() but it returns an array of objects that fulfill the condition.   <pre><code>&gt; arr.filter( item =&gt; item.age == 34 );\n[ { id: 1, age: 34 }, { id: 3, age: 34 } ]\n</code></pre>"},{"location":"Data%20Types/#transforming-arrays","title":"Transforming arrays","text":"\u2699 method arr.map(function) : returns a new array of the results of the function   <pre><code>&gt; let arr = [ 1,2,3,4,5 ]\n&gt; arr.map(item =&gt; item + 1);\n[ 2,3,4,5,6 ]\n\n&gt; [ \"a\", \"ab\", \"abc\" ].map( item =&gt; item.length ) \n[ 1,2,3 ] \n</code></pre>  \u2699 method arr.**sort(func)** :- sorts arr based on func, if func is not given it will treat it like a string   <pre><code>&gt; [ 13, 5, 1].sort();\n[ 1, 13, 5 ] // because it tried to sort it like a string\n/* if we want it to sort based on a function, we need to supply a function of two\n * arguments */\n&gt; function comp( a, b ) { \n            if( a &gt; b ) return 1;\n            if( a &lt; b ) return -1; \n            if( a === b) return 0;\n }\n&gt; [ 13, 5, 1].sort(comp);\n[ 1, 5, 13 ]\n\n/* compare functions are only required to return a positive number to say greate and a\n * negative number to say less, so we can do this instead */\n&gt; [ 13, 5, 1].sort( (a, b) =&gt; a - b )\n[ 1, 5, 13]\n</code></pre>  \u2699 method **arr.reverse()** :- reverses the array and returns it. it will change the array   <pre><code>let ar = [ 1, 2, 3, 4 ]\nar.reverse() // [ 4, 3, 2, 1 ]\nar // [ 4, 3, 2, 1 ]\n</code></pre> <p>split and join</p>  \u2699 method string.split(delimiter, limit) : splits a string into an array based on the delimiter    \u2699 method arr.join(delimiter) : does the reverse of split()   <pre><code>let str = \"hello , world\";\nstr.split() // [ \"hello , world\" ]\nstr.split(\"\") // [ 'h', 'e', 'l', 'l', 'o', ' ' , ',', 'w' ...]\narr = str.split(\",\") // [ \"hello \", \" world\" ]\narr.join(\":\") // \"hello : world\"\n\nstr.split(\",\", 1) // [ \"hello\" ]\n</code></pre> <p>reduce and reduceRight</p>  \u2699 method arr.reduce( func( previous, item, index, array) ) :- reduces the array into a single value based on the function passed   <pre><code>let arr = [ 'a', 'b', 'c', 'd' ]\narr.reduce ( (prev, item) =&gt; prev + \",\" + item ); // 'a,b,c,d'\nlet arr2 = [ 1, 2, 3, 4 ]\narr2.reduce( (prev, current) =&gt; prev + current, 0 ); // 10 \n/* we can specify an initial prev after the comma, we gave it 0 above\n</code></pre> <p>reduceRight() : does the same thing but does it from the right</p> <p>Array.isArray(arr) : returns true if arr is an array</p> <p>all array methods except sort() support an additional thisArg</p> <p>Array methods cheat-sheet</p>"},{"location":"Data%20Types/#iterables","title":"Iterables","text":"<p>Iterables are objects that can be used by a for \u2026 of loop</p>"},{"location":"Data%20Types/#symboliterator","title":"Symbol.iterator","text":"<p>To make our on iterable objects we have to add a method  called Symbol.iterator, which returns an iterator object which includes a method called next which returns an object of the format { done: boolean, value: next_value }.</p> <pre><code>let range = {\n    from: 1,\n    to: 5,\n}\n\nrange[Symbol.iterator] = function(){\n    return{\n        this.current = this.from,\n        this.last = this.to,\n        next(){\n            if(this.current &lt;= this.last)\n                    return { done: false, value: this.current++ }\n            else\n                    return {done: true}\n        }\n}\n}\n\nfor(i of range) console.log(i) // 1, 2, 3, 4, 5\n</code></pre> <p>The object we want to iterate over can be used as the iterator itself to make the code simpler</p> <pre><code>let range = {\n    from: 5,\n    to: 10,\n\n    [Symbol.iterator](){\n            this.current = this.from;\n            return this\n    }\n\n    next(){\n        if(this.current &lt;= this.to)\n            return { done: false, value: this.current++}\n        else\n            return { done: true }\n    }\n}\n\nfor( i of range ) // 5 6 7 8 9 10\n\n/* But this implementation won't allow us to run simultaneously because they will\n * share the same iteration state */\n</code></pre> <p>Calling an iterator explicitly</p> <p>We can iterate oven an iterable manually</p> <pre><code>let str = \"hello\"\nlet iterator = str[Symbol.iterator]();\n\nwhile(true){\n    let result = iterator.next();\n    if(result.done) break;\n    console.log(result.value)\n}\n</code></pre> <p>Iterables and array-likes</p> <p>Iterables are objects that implement the Symbol.iterator method and Array likes are those that have indexes and a length property.</p> <p>Array.from(obj, [mappingFunc, thisArg]) creates arrays from iterables or array-likes</p> <pre><code>let a = Array.from(range) // the previous iterable\na // [ 5,6,7,8,9,10 ]\n// we can pass a mapping function to be applied\nlet b = Array.from(range, num =&gt; num*2 ) \nb // [10, 12, 14, 16, 18, 20 ]\n\n// to get array of characters from a string\nlet str = \"hello\"\nlet c = Array.from(str)\n// this approach unlike split, works fine with surrogate pairs\n</code></pre>"},{"location":"Data%20Types/#maps","title":"Maps","text":"<p>Maps are like objects in that they are keyed collections of data items, but unlike objects maps allow keys of any types.</p>  \ud83d\udea8 Main methods                                                                                                                                                    - **new Map()**  - create a map                                                                                                                      - **map.set(key, value)** - stores the value by key                                                                                   - **map.get(key)** - gets value by key                                                                                                                        - **map.has(key)** - returns true if key exists                                                                                                                     - **map.delete(key)** - deletes value by key                                                                                                - **map.clear()** - clears the map                                                                                                                 - **map.size** - returns the size of the map   <pre><code>let a = new Map()\na.set(1, \"a\")\na.set('1', \"b\")\na.set(true, \"c\")\n\na.get(1) // 'a'\na.get('1') // 'b'\na.get(true) // 'c'\n\na.has(false) // false\n</code></pre> <p>Every map.set() return the map itself so we can chain our sets</p> <pre><code>a.set(1, \"a\").set('1', \"b\").set(true, \"c\")\n</code></pre> <p>Maps from objects</p> <p>we can pass an array or other iterables with key value pairs when creating a map</p> <pre><code>let a = new Map([ 1, \"a\"],\n                                [ \"2\", \"b\"],\n                                [ false, 4 ]);\n</code></pre> <p>The method Object.entries(obj)  creates a key value pair array from an object</p> <pre><code>let obj = {\n    name: \"dani\",\n    age: 56,\n    sex: \"male\"\n}\nlet ent = Object.entries(obj);\nent // [ [\"name\", \"dani\"], [\"age\", 56], [\"sex\", \"male\"] ]\n\nlet m = new Map(ent);\n</code></pre> <p>Iteration over maps</p> <p>maps.keys() - returns an iterable for keys</p> <p>maps.values() - returns an iterable for values</p> <p>maps.entries() - returns an iterable for entries, it\u2019s used by default in a for\u2026of loop</p> <pre><code>&gt; let m = new Map(Object.entries({ name: \"jim\", age: 45, height: 174 }) );\n\n&gt; for( i of m.keys() ) console.log(i)\nname\nage\nheight\n&gt; for( i of m.values() ) console.log(i)\njim\n45\n174\n&gt; for( i of m ) console.log(i)  // same as m.entries()\n[ \"name\", \"jim\" ]\n[ \"age\", 45 ]\n[ \"height\", 175 ]\n</code></pre>"},{"location":"Data%20Types/#set","title":"Set","text":"<p>A set is a collection of values where a value can only occur once.</p>  \ud83d\udea8 Methods                                                                                                                                           **new Set( iterable )**  - creates a set, if an iterable is given in copies it in                                     **set.add( value )** - adds a value to a set                                                                                                            **set.delete( value )** - removes a value from a set                                                                                       **set.has( value )** - checks to see if the set has that value                                                                                     **set.clear()** - clears the set                                                                                                                        **set.size** - elements count   <p>iterating over a set</p> <p>we can iterate over the set using a for.. of. loop of a forEach()</p> <pre><code>let set = new Set( [ 1, 3, 5, 6 ] ) \nfor( i of set ) console.log(i) // 1, 3, 5, 6\n\nset.forEach( (value, valueAgain, map) =&gt; console.log(value) ) // 1, 3, 5, 6\n\n/* The callback function called in forEach passes three arguments of which 2 are the \n * values, this is done for compatibility with maps. In this spirit sets also have\n * the methods to return iterables, set.keys(), set.values(), set.entries() \n * keys() and values() both return the values, and entries returns [ value, value ]*/\n</code></pre>"},{"location":"Data%20Types/#weakmap-and-weakset","title":"WeakMap and WeakSet","text":"<p>The garbage collector doesn\u2019t free up objects if they are referenced in arrays, maps or sets.</p> <pre><code>let obj = { str: \"I'll live forever\" }\nlet arr = new Array(obj);\nobj = null;\narr // [ { str: \"I'll live forever\" } ]\n</code></pre> <p>WeakMap and WeakSet don\u2019t prevent the garbage collector from doing it\u2019s job.</p> <p>WeakMaps and WeakSets</p> <p>WeakMaps can\u2019t have primitive values as their keys. WeakMaps don\u2019t support iteration.</p>  \ud83d\udea8 WeakMap methods                                                                                                                                **new WeakMap() -** creates a weak map                                                                                                 **weakmap.get( key ) -** gets a value                                                                                                                         **weakmap.set( key, value )                                                                                                                            weakmap.has( key )                                                                                                                           weakmap.delete( key )**   <p>The garbage collector performs clean up at a time of it\u2019s choosing, so the size of weakmap can\u2019t   be known, that\u2019s why the other methods can\u2019t operate on weakmaps. Weaksets are analogous to sets</p>"},{"location":"Data%20Types/#objectkeysobj-valuesobj-and-entriesobj","title":"Object.keys(obj) .values(obj) and .entries(obj)","text":"<p>Objects just like maps and sets also support these methods, but unlike maps and sets they return arrays and not iterables,</p> <pre><code>let obj = { name: \"candy\", sweet: true }\n\nObject.keys(obj) // [ \"name\", \"sweet\" ]\nObject.values(obj) // [\"candy\", true ]\n</code></pre> <p>These methods also ignore symbol properties, but we can use methods Object.getOwnPropertySymbols(obj)  - to return only the symbolic keys and method Reflect.ownKeys(obj) - to get all the keys</p> <p>Object.fromEntries( [] ) - creates objects from entries, or maps</p> <pre><code>let arr = [ [\"name\", \"candy\"], [\"sweet\",true] ]\nObject.fromEntries(arr) // { name: \"candy\", sweet: true }\n// also works on maps\n</code></pre>"},{"location":"Data%20Types/#destructuring-assignment","title":"Destructuring assignment","text":"<p>destructuring assignment is a special syntax that allows us to unpack arrays or objects in to variables.</p> <p>Array destructuring</p> <pre><code>// Array destructuring\nlet [ first, last ] = [ \"Barack\", \"Obama\" ]\n// we could also do this\nlet [ first, last ] = \"Barack Obama\".split(\" \");\n// we can skip over unwanted elements with commas\n</code></pre> <p>We can use any iterable on the right side</p> <pre><code>let map = new Map();\nmap.set(\"name\",\"jhon\").set(\"age\",8).set(\"height\", 174);\nlet [ first, , last ] = map\nfirst // \"name\", \"jhon\"\nlast // \"height\", 174\n// or string\n[a, b, c] = \"1234\";\na // 1\nb // 2\n\n</code></pre> <p>We can also store the rest of the elements of the array using \u2026var, with var being an array of everything else</p> <pre><code>let arr = \"hello world this is javascript speaking\".split(\" \");\nlet [ a, b, ...c] = arr\na // hello\nb // world\nc[0] // this\nc[1] // is\n</code></pre> <p>When there are fewer elements in the array than the variables, the remaining variables are passed undefined.</p> <p>We can define default values for the variables if that happens</p> <pre><code>let [ a = \"empty\", b = \"empty\"] = [\"hello\"]\na // hello\nb // empty\n\n// the default values can also be calls to functions\n</code></pre> <p>Object destructuring</p> <pre><code>let obj = {\n    name: \"Andy\",\n    sex: \"male\",\n    age: 13,\n}\n\nlet { age, sex, name } = obj; // order doesn't matter\n</code></pre> <p>If we want to assign the properties to variables with a different name we can use a colon</p> <pre><code>let { name: n, sex, age: years } = obj\n</code></pre> <p>For potentially missing values we can specify a default using = </p> <pre><code>let { name, country = \"UK\", age } = obj\nname // \"Andy\"\ncountry // \"UK\"\n// default values can also be calls to functions\n</code></pre> <p>If we want to combine both the equality and colon , we can do so as such</p> <pre><code>let { name: n = \"Jhon\" } = obj\n</code></pre> <p>If we want the rest of the objects properties we can use \u2026var, where var will be an object with the rest of the properties</p> <pre><code>let { name, ...rest } = obj\nname // \"Andy\"\nrest // { sex: \"male\", age:13 }\nrest.age // 13\n</code></pre> <p>Nested destructuring</p> <p>If an object or array contains other objects and arrays we can use nested destructuring to extract the deeper portions.</p> <pre><code>let box = {\n    size: {\n        width: 3,\n        height: 5,\n        depth: 2,\n    },\n    colors: [ \"red\", \"green\" ],\n}\n\nlet {\n        size: {\n            width,\n            height,\n        },\n        colors: [ color1, color2 ],\n} = box;\n\nwidth // 3\nheight // 5\ncolor1 // red\nsize // undefined\ncolors // undefined\n</code></pre>"},{"location":"Data%20Types/#smart-function-parameters","title":"Smart function parameters","text":"<p>When we have many parameters of which several are optional, it can become hard to remember their position, we can work around this problem by using object destructuring. we can pass them objects and the use the function to destructurize them into variables.</p> <pre><code>let movie = {\n    title: \"Avengers\",\n    genre: [ \"action\", \"drama\" ],\n};\n\nfunction showMovie ( {title = \"no title\", duration = 2.00, genre} ){\n    console.log(` ${title} , ${duration} , ${genre} `);\n}\n\nshowMovie(movie);\n// Avengers, 2.00, action, drama\n\n// we can also specify default values and new names\nfunction showMovie( { title: name = \"no title\", duration = 2.00, genre: [ g1 ]})\n\n/* if we want all defaults we can't just do showMovie() but showMovie({}), to work \n * around this problem we can specify {} as a default for the whole parameter */\n\nfunction showMovie( {title = \"no title\", genre: [g1, g2]} = {} ) {} \n// doing ={} will make it possible to just call showMovie()\n</code></pre>"},{"location":"Data%20Types/#date","title":"Date","text":"<p>Creation</p> <p>new Date() // without arguments creates a date object for the current date and time.</p> <p>new Date( milliseconds ) // creates a date object with the time equal to the number of milliseconds past since the Jan 1- 1970. The number of milliseconds past since since 1970 is called a timestamp</p> <p>new Date( date string ) \u2014 the date string get parsed with the Date.parse algorithm</p> <p>new Date( year, month, day, hours, minutes, seconds, milliseconds ) - The first two arguments are obligatory . Year must have four digits. month count starts from 0 - 11. default of day is 1. If the rest are missing they are assumed to be 0.</p> <pre><code>new Date() // 2022-07-12T07:19:10.943Z -- current time\nnew Date(0) // 1970-01-01T00:00:00.000Z\nnew Date(\"2020-4-8\") // 2020-04-07T21:00:00.000Z\nnew Date(1994, 4) // 1994-04-30T21:00:00.000Z\nnew Date(2002, 9, 11, 4) // 2002-10-11T01:00:00.000Z\n</code></pre> <p>Access date components</p> <p>getFullYear() - get the year ( 4 digit ) </p> <p>getMonth() - </p> <p>getDate() - </p> <p>getHours(), getMinutes(), getSeconds(), getMilliseconds()</p> <p>getDay() // 0-6 , where 0 is sunday</p> <p>// These methods also have UTC counterparts like getUTCHours(), getUTCMinutes() etc.</p> <p>getTime() // returns the date\u2019s timestamp since Jan1/ 1970 UTC+0. has no UTC variant</p> <p>getTimezoneOffset() //  returns the difference b/n local time zone and UTC in minutes</p> <p>Modify date components</p> <p>setFullYear( year [, month, date ] )</p> <p>setMonth( month [, date] )</p> <p>setDate( date ) </p> <p>setHours( hours [, minutes, seconds, millis ] )</p> <p>setMinutes( minutes [, seconds, millis ] )</p> <p>setSeconds( seconds [, millis ] )</p> <p>setMilliseconds( millis )</p> <p>setTime ( timestamp ) </p> <p>Autocorrection</p> <pre><code>let a = new Date(\"2002\\1\\30\");\n\na.setDate(a.getDate() + 4) \na // 2002-02-02T21:00:00.000Z\n\n// we can use this technique to get the date after some time has elapsed\na.setMinutes( a.getMinutes() + 40 )  // date after 40 minutes\na.setSeconds( a.getSeconds() + 4900 ) // date after 4900 seconds \n</code></pre> <p>We can also set numbers \u2264 0</p> <pre><code>let a = new Date(\"2002/2/23\");\na.setDate(0) // last day of previous month\na.setDate(-3) // before 3 days and before 3 month for some reason\n</code></pre> <p>Casting to numbers</p> <p>when dates get cast into numbers they return their timestamps.</p> <pre><code>let a = new Date(2002, 1, 23);\n+a // 1014411600000\n</code></pre> <p>Date.parse()</p> <p>The string format should be: YYYY-MM-DDTHH:mm:ss.sssZ , </p> <p>where: YYYY-MM-DD \u2013 is the date: year-month-day. The character \"T\" is used as the delimiter. HH:mm:ss.sss \u2013 is the time: hours, minutes, seconds and milliseconds. The optional 'Z' part denotes the time zone in the format +-hh:mm . A single letter Z that would mean UTC+0.</p>"},{"location":"Data%20Types/#json-javascript-object-notation","title":"JSON - ( JavaScript Object Notation )","text":"<p>Is a general format to represent Objects and values. It\u2019s a data only cross language specification.</p> <p>JSON.stringify() \u2014 converts objects in to strings, the resulting strings are called JSON-encoded or serialized or stringified or marshalled object.</p> <p>JSON.parse() \u2014 converts JSON into objects</p> <pre><code>let obj = {\n    name: \"my object\",\n    description: 'an object',\n}\nlet a = JSON.stringify(obj);\na // '{\"name\":\"my object\",\"description\":\"an object\"}'\ntypeof a // 'string'\n\nlet b = JSON.parse(a);\nb // { name: 'my object', description: 'an object' }\n</code></pre> <p>JSON-encoded objects - use only double quotes for strings, so \u2018an object\u2019 becomes \u201can object\u201d. They also double quote property names so name becomes \u201cname\u201d.</p> <p>JSON methods can natively be applied to objects, arrays, primitives(strings, numbers, booleans, and null)</p> <p>JSON.strigify() - skips methods, symbol properties, and properties that store undefined, since it\u2019s data only </p> <pre><code>let obj = {\n    method() { /* do smth */ },\n    prop1: undefined,\n    [Symbol(\"id\")]: '01',\n}\n\nJSON.stringify(obj) // '{}'\n</code></pre> <p>stringify() \u2014 supports nested objects, as long as there\u2019s no circular references.</p> <pre><code>let room = { number: 23 };\nlet meetup = { \n    title: \"Conference\",\n    participants: [\"john\", \"ann\"]\n};\nmeetup.place = room; // meetup references room \nroom.occupiedBy = meetup; // room references meetup \nJSON.stringify(meetup); // Error: Converting circular structure to JSON\n</code></pre> <p>JSON.stringify( value [, replacer, space] )</p> <p>where replacer is an array of properties to encode or a mapping function(key, value) and space is the amount of space to use for formatting.</p> <p>replacer</p> <p>passing an array</p> <pre><code>let obj = {\n    name: \"candy\",\n    age: 50,\n    other: [{height: 5.6}, {weight: 140}],\n    sex: \"f\",\n}\nlet s = JSON.stringify(obj, [\"name\", \"age\", \"other\", \"height\"])\ns // '{\"name\": \"candy\", \"age\": 50, \"other\": [{\"height\": 5.6}, {}]}'\n// properties \"sex\" and \"weight\" are not encoded since they are not mentioned\n/* we can safely skip properties that cause circular references by not adding them\n * to the replacer array */\n</code></pre> <p>passing a function</p> <pre><code>// let's make candy 12 years old\nlet s = JSON.stringify(obj, (key, value) =&gt; {\n        return key == \"age\" ? 12 : value;\n});\n\ns // '{\"name\": \"candy\", \"age\": 12, \"other\": [{\"height\": 5.6}, {}]}'\n</code></pre> <p>The first call passes a key value pair with the key(\u201d\u201d) and value of the object itself { \u201c\u201d: obj }</p> <p>spaces</p> <p>used to specify the number of spaces used for indentation, used for logging and output</p> <pre><code>let obj = { continent: \"Africa\", countries: [ \"Ethiopia\", \"Mali\" ] }\n/*\n{\n  \"continent\": \"Africa\",\n  \"countries\": [\n    \"Ethiopia\",\n    \"Mali\",\n  ]\n}\n*/\n</code></pre> <p>Custom toJSON conversion</p> <p>Just like toString() we can add a toJSON() method to our objects. JSON.stringify() calls this method if it exists</p> <pre><code>let room = {\n    number: 1,\n    toJSON() {\n        return this.number;\n    }\n}\n\n    JSON.stringify(room) // 1\n</code></pre> <p>JSON.parse(str [, reviver])</p> <p>we can customize the parsing of json to objects by passing a reviving function.</p> <pre><code>// consider the case \nlet obj = { name: \"Elias\", dob: new Date() }\nlet json = JSON.stringify(obj)\njson // '{\"name\":\"Elias\",\"dob\":\"2022-07-13T08:24:52.846Z\"}'\nlet obj2 = JSON.parse(json)\nobj2 // { name: 'Elias', dob: '2022-07-13T08:24:52.846Z' }  ! dob became a string\n\nlet obj3 = JSON.parse(json, (key, value) =&gt; { \n    return key == \"dob\" ? new Date(value) : value;\n});\nobj3 // '{\"name\":\"Elias\",\"dob\":\"2022-07-13T08:24:52.846Z\"}'\n</code></pre>"},{"location":"Object%20properties%20configuration/","title":"Object properties configuration","text":""},{"location":"Object%20properties%20configuration/#property-flags-and-descriptors","title":"Property flags and descriptors","text":"<p>Object properties besides a value have three special attributes. writable, enumarable, and configurable.</p>"},{"location":"Object%20properties%20configuration/#objectgetownpropertydescriptorobj-propertyname","title":"<code>Object.getOwnPropertyDescriptor(obj, propertyName)</code> <code>Object.defineProperty( obj, property, descriptor)</code>","text":"<p>We can list these attributes using <code>Object.getOwnPropertyDescriptor(obj, propertyName)</code></p> <pre><code>&gt;&gt; let obj = {\n    name: \"Smith\",\n    age: 23,\n}\n\n&gt;&gt; let descriptor = Object.getOwnPropertyDescriptor(obj, \"name\");\n&gt;&gt; descriptor\n{\nvalue: 'Smith',\nwritable: true,\nenumarable: true,\nconfigurable: true,\n}\n</code></pre> <ul> <li>Writable - can be changed, otherwise is read only</li> <li>enumerable - get's listed in loops, otherwise not</li> <li>configurable - property can get deleted, and these attributes can be modified, or else not</li> </ul> <p>To change the flags we can use <code>Object.defineProperty( obj, property, descriptor)</code></p> <pre><code>&gt;&gt; Object.definePropery(obj, age, {value: 4, writable: false});\n&gt;&gt; Object.getOwnPropertyDescriptor(obj, \"age\")\n{\n    value: 4,\n    writable: false,\n    enumarable: true,\n    configurable: true,\n}\n</code></pre> <p>If the propery exists , <code>defineProperty</code> updates it's flags, if it doesn't, it will create the property and set all unspecified flags as false. </p> <pre><code>&gt;&gt; Object.defineProperty(obj, height, {value: 174});\n&gt;&gt; let desc = Object.getOwnPropertyDescriptor(obj, \"height\");\n&gt;&gt; desc\n{\n    value: 174,\n    writable: false,\n    enumerable: false,\n    configurable: false\n}\n</code></pre> <ul>The effects of the flags</ul> <p>writable - If we try to change the value of a non writable ( read only ) property, in strict mode it will cause an error, and if we are not in strict mode it will simply ingnore it.</p> <pre><code>let user = {};\nObject.defineProperty(user, \"name\", {value: \"Andy\"});\n\nuser.name = \"candy\"\n// if we are in strict mode this will cause an error\n// in non-strict mode flag violating operations will simply get ignored\n\nuser.name // \"Andy\"\n</code></pre> <p>enumerable - If this flag for a property is false, then it won't get show listed in a <code>for...in</code>, and it will also get excluded from an <code>Object.keys</code> </p> <pre><code>&gt;&gt; let user = {\n        name: \"andy\",\n        toString(){ return this.name }\n    }\n\n&gt;&gt; Object.keys(user);\n['name', 'toString']\n\n&gt;&gt; Object.defineProperty(user, \"toString\", {enumerable: false});\n&gt;&gt; for( i in user) console.log(i);\n'name'\n\n</code></pre> <p>configurable - A non-configurable property can't get deleted or modified by another <code>Object.defineProperty()</code> , trying to do so will cause an error.</p>"},{"location":"Object%20properties%20configuration/#objectdefinepropertiesobj-descriptors","title":"<code>Object.defineProperties(obj, descriptors)</code>","text":"<p>Allows us to define multiple properties at once.  <code>Object.defineProperties(obj, descriptors)</code>. It returns the object</p> <pre><code>let user = {}\nObject.defineProperties(user, {\n    name: {value: \"max\", writable: true, enumerable: true},\n    age: {value: 10, writable: true, enumerable: true}\n})\n</code></pre>"},{"location":"Object%20properties%20configuration/#objectgetownpropertydescriptorsobj","title":"<code>Object.getOwnPropertyDescriptors(obj)</code>","text":"<p>returns an object with all the properties of obj, and their descriptors. This method can be used to create a flag aware clone of an object.</p> <pre><code>\nlet clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));\n</code></pre>"},{"location":"Object%20properties%20configuration/#sealing-an-object-globally","title":"Sealing an object globally","text":"<p>There are methods which limit access to whole objects. These methods are rarely used in practice</p> <ul> <code>Object.preventExtension(obj)</code> <ul>Forbids addition of new properties to a obj</ul> </ul> <ul> <code>Object.seal(obj)</code> <ul>Forbids adding/ removing of properties, set's <code>configurable: false</code> for all existing properties</ul> </ul> <ul> <code>Object.freeze(obj)</code> <ul>Forbids adding/removing/changing of properties, set's <code>writable: false, configurable: false</code> for all existing properties.</ul> </ul> <ul> <code>Object.isExtensible(obj)</code> <ul>returns true if obj is extensible</ul> </ul> <ul> <code>Object.isSealed(obj)</code> <ul>returns true if obj is sealed</ul> </ul> <ul> <code>Object.isFrozen(obj)</code> <ul>returns true if obj is frozen</ul> </ul>"},{"location":"Object%20properties%20configuration/#getter-and-setter-properties","title":"Getter and Setter properties","text":"<p>There are two types of properties, data properties and accessor properties. Accessor properties are essentially functions that work on getting and setting properties. They are denoted by <code>get</code> and <code>set</code> literals.</p> <pre><code>// Their syntax\nlet obj = {\n    get propName(){}\n    set propName(value){}\n}\n</code></pre> <p>Let's declare a fullname accessor property inside object user</p> <pre><code>\nlet user = {\n    firstName: \"Biruk\",\n    lastName: \"Tesfa\",\n    get fullName(){\n        return `${this.firstName} ${this.lastName}`\n    }\n    set fullName(str){\n        [this.firstName, this.lastName] = str.split(\" \");\n    }\n}\n\nuser.firstName // 'Biruk'\ntypeof user.fullName // String\nuser.fullName // 'Biruk Tesfa'\nuser.fullName = \"Girma Taye\"\nuser.fullName // 'Girma Taye'\nuser.firstName // 'Girma'\nuser.lastName // 'Taye'\n</code></pre>"},{"location":"Object%20properties%20configuration/#accessor-propertys-descriptors","title":"accessor property's descriptors","text":"<p>Descriptors for accessor properties, have no <code>value</code> and <code>writable</code> fields but they have <ul> <li><code>get</code> - function</li> <li><code>set</code> - function with one argument</li> <li><code>enumerable</code></li> <li><code>configurable</code></li> <p> We can use <code>Object.defineProperty()</code> to create accessor properties</p> <pre><code>\nlet obj = {}\n\nObject.defineProperty(obj, \"propName\", {\n    get(){},\n    set(arg){},\n    enumerable: true, \n})\n\nObject.getOwnProperties(obj);\n/*\n{\n    propName: {\n        get: [Function: get],\n        set: [Function: set],\n        enumerable: true,\n        configurable: false\n    }\n}\n*/\n</code></pre> <p>If we run the following code  <code>Object.defineProperty(obj, \"propName\", {value: \"smth\";})</code> Then <code>propName</code> will no longer be an accessor method but a data property.</p> <p>If we try to pass a descriptor containing, say a <code>value</code> or a <code>writable</code> and a <code>get</code> or <code>set</code>, it will give us a TypeError because we can't specify both an accessor and a value attribute.</p> <p>Getters and Setters can be used as wrappers over data properties to gain more control over them.</p> <pre><code>\nlet obj = {\n    get average(){ return this._average},\n    set average(value){\n        if(value &lt; 0 || value &gt; 100) return;\n        this._average = value;\n    }\n}\n\nobj.average // undefined\nobj.average = -2  // will revert because value passed is &lt; 0\nobj.average // undefined\nobj.average = 79 \nobj.average // 79\n\n\n// we can also call _average directly\nobj._average // 79\n// But it's attributes that start with underscore are regarded to be internal and \n// we should not directly interact with them from outside.\n</code></pre>"},{"location":"Objects/","title":"Objects","text":"<p>An object is a key: value pair collection.</p> <p>Object properties can only be of type string or symbol. Properties of other types are casted into strings</p> <pre><code>let user = new Object(); // object constructor syntax\nlet user = {}; // object literal syntax\n\nlet user  = {\n    name: \"no-name\", \n    age: 6,\n    \"favorite book\": \"Harry poter\",  // multiword identifiers\n}\n\nuser.name // no-name\nuser[\"name\"] // no-name\nuser['age'] // 5\nuser.favorite book // error\nuser.\"favorite book\" // error\nuser[\"favorite book\"] // harry poter\n\nuser // { name: 'no-name', age: 6, 'favorite book': 'harry poter' }\nuser[\"profession\"] // undefinedd\nuser // { name: 'no-name', age: 6, 'favorite book': 'harry poter' }\nuser[\"profession\"] = \"nurse\";\nuser // { name: 'no-name', age: 6, 'favorite book': 'harry poter' , profession: 'nurse' }\n\nuser.height = 7.8;\nuser // { name: 'no-name', age: 6, 'favorite book': 'harry poter' , \n            //  profession: 'nurse', height: 7.8 }\n\ndelete user.heigth;\nuser //  { name: 'no-name', age: 6, 'favorite book': 'harry poter' , profession: 'nurse' }\n</code></pre>"},{"location":"Objects/#computed-properties","title":"computed properties","text":"<p>[ ] denote computed properties</p> <pre><code>// we can use computed properties in two ways\nlet user = {\n    name: \"smt\",\n    age: 5,\n}\nlet key = \"name\";\nuser[key] // -&gt; smt , [] will compute the evaluate key to name\n\n// in declaration\nkey = \"name\";\nuser = {\n    [key]: \"nameless\"\n    [ \"$\".repeat(5) ]: \"smth\",\n}\n\nuser // { name: \"nameless\", '$$$$$': \"smth\" } \n</code></pre>  \u26a0\ufe0f Reserved key words are allowed as property names   <pre><code>let user = {\n    for: 'smth',\n    let: 'smth else',\n}\n\n// __proto__ . is allowed but will cause issues\n</code></pre>  \u26a1 Property value shorthand   <pre><code>(name, age) =&gt; {\n    return { \n        name: name,\n        age: age,\n    }\n}\n\n// is the same as\n\n(name, age) =&gt; {\n    return {\n        name, age\n    }\n}\n\n// we can mix them up if we like\n(name, age) =&gt; {\n    return {\n        name, age, height: 1.78\n    }\n}\n\n</code></pre>  \u26a0\ufe0f **Checking for existence**   <p>If a property doesn\u2019t exist and we try to access it, it will return undefined. we can use this</p> <pre><code>user.property === undefined // it doesn't exist\n/* checking if it === undefined will fail if the property exists by contains undefined*/\n\n/* We can also use the (in) operator \n    \"key\" in object\n     key in object\n*/\n\nlet user =  {\n    key: 45,\n    tag: 4,\n    1: 8,\n}\nlet m = \"tag\";  \n\n\"key\" in user // true\nm in user // true   -- variable m containig the name \" tag \" got tested\n1 in user // true\n\"1\" in user // true\n</code></pre>  \ud83d\udccc The for \u2026 in \u2026 loop   <pre><code>for( key in object ); // iterates over the propeties of objects, typeof(key) -&gt; string\n</code></pre> <p>Integer properties are sorted, others appear in order of creation . </p> <pre><code>//if we don't want our integer property names to be sorted we can cheat by adding + \nlet code = {\"+1\": 4, \"+4\": 9,}\n</code></pre>  \u26a0\ufe0f Object variables store references   <pre><code>\n//because of this == and === on objects equate the referances\n// and const objects can be changed without changing their reference\nconst a = { name: \"cara\" }\na.name = \"jhon\" // will work\na = {}  // error\n\n</code></pre>"},{"location":"Objects/#cloning-objects","title":"cloning objects","text":"<p>There are several way for cloning objects</p> <pre><code>\nlet obj1 = { p1: 1, p2: 2 }\nlet obj2 = {}\n\n// using for... in\nfor( key in obj1 ) {\n    obj2[key] = obj1[key]\n}\n\n// using Object.assign()\n// Object.assing(dest, [arg1, arg2, ...] )  =&gt; returns dest\n// we can use it to copy multiple objects into one\n// the destination objects properties will be overwritten if they already exist\n\nobj2 = Object.assign({}, obj1); \n// or simply Object.assign(obj2, obj1)\n\n</code></pre>  \u26a0\ufe0f READ GARBAGE COLLECTION   <p>A general book \u201cThe Garbage Collection Handbook: The Art of Automatic Memory Management\u201d (R. Jones et al) covers some of them.</p>"},{"location":"Objects/#symbols","title":"Symbols:","text":"<p>A symbol value represents a unique value.</p> <pre><code>// symbols can be created like\nlet l = Symbol([description string]);\nlet m = Symbol.for(\"smth\"); // global Symbols\n</code></pre> <p>Symbols don\u2019t auto-convert into strings</p> <p>To use symbols as object properties we can do the following</p> <pre><code>let sym = Symbol();\nlet sym2 = Symbol();\n\nlet obj = { \n    [sym]: \"smth\"\n} ;\n\nobj[sym2] = \"smth else\"; \n</code></pre> <p>Hiding symbolic properties principle</p> <p>Symbols are skipped in a for\u2026 in loop</p> <p>Symbols are skipped in a Object .keys(object)</p>  \u26a0\ufe0f In contrast Object.assign(), copies both string and symbolic properties    \ud83c\udf10 Global symbols:  If we want to access the same symbols from different parts of our code we can use the global symbol registry. We can do that by creating symbols by using ( Symbol .for([\u201ddescription\u201d]). if there exists a symbol with a matching description it will be returned otherwise it will be created   <pre><code>let a = Symbol.for(\"abc\");\nlet b = Symbol.for(\"abc\");\na == b // true\n\nSymbol.keyFor(a) // abc\n</code></pre> <pre><code>// System Symbols\nSymbol.hasInstance\nSymbol.toPrimitive  // and etc \n</code></pre> <pre><code>// Symbols are not really hidden\n// we can use \nObject.getOwnPropertySymbols(obj) // return symbol properties\nReflect.ownKeys(obj) // returns all keys including symbolic ones\n</code></pre>"},{"location":"Objects/#methods","title":"Methods","text":"<p>Are properties of an object that are functions</p> <pre><code>// ways to declare methods\nlet a = { } \na.method1 = function () { /* */ }\n\nfunc2 = function() { } \nlet b = { }\nb.func2 = func2\n\nlet c = {\n    func3: function(){}\n    func4() { } // short hand\n}\n\n// this. keyword\n\nlet user = {\n    name: \"usr1\",\n    sayHi(){\n        console.log(\"hi \" + this.name);\n    }\n}\n</code></pre>  \ud83d\udc49\ud83c\udfff this. is evaluated at runtime, so the following things are possible   <pre><code>let f = function() { alert(this.id) }\nlet o1 = { id: 1 } \nlet o2 = { id: 2 } \no1.f = f\no2.f = f\n\no1.f() // 1\no2.f() // 2\n\n/* this. is not bound i.e. it can be called anywhere, if it has no\n * referance, it will return the window object if it's no in strict mode\n * and undefined if it is in strict mode\n*/\n</code></pre> <p>Reference type:</p> <p>The way method calls work, is by breaking up the process in to two operations</p> <pre><code>obj.func() // there are two operations here, 1- the dot operator, and 2- ()\n/* In method calls, the dot operator doesn't return a function but a special\n * intermediate internal reference type with the purpose of passing info from\n * the dot operator to the parenthesis, its composed of: \n *                      1. base (i.e. the object)\n *                      2. name (i.e. the property name)\n *                      3. strict(i.e. bool whether it's in strict mode) \n * when the parenthesis are called on the reference type, they recieve full info\n * about the object and it's methods, so this. will work\n * other operations like assignment( a = obj.func ), discard the reference type and \n * return the function instead. \n */ \nlet obj = {\n    id: \"01\",\n    printId() { \n        alert(\"id: \" + this.id )\n    }\n}\nobj.printId() // id: 01\nlet func = obj.printId\nfunc() // id: undefined\n</code></pre>  \ud83d\udc49\ud83c\udfff Arrow functions have no this, if this. is used inside them it\u2019s taken from the outer context"},{"location":"Objects/#object-to-primitive-conversion","title":"object to primitive conversion","text":"<p>All objects are true in Boolean context. there are only numeric and string conversions</p> <p>During object to primitive conversion, JavaScript tries to find and call three object methods. </p> <ol> <li>Symbol.toPrimitive(hint) is called if it exists, hint is either \u201cstring\u201d , \u201cnumber\u201d, or  \u201cdefault\u201d , hint is the type of the conversion, \u201cdefault\u201d is called when the conversion is unclear, eg ( the binary + operator) can add numbers and concat strings and also the == operator resolves to \u2018default\u2019</li> <li>for \u201cstring\u201d hints , it tries to find and do toString() then valueOf()</li> <li>for non-string hints, valueOf() \u2192 toString() </li> </ol> <p>All built in Objects except Date implement \u2018default\u2019 as number.   &gt;&lt; resolve to \u2018number\u2019</p> <pre><code>let user = {\n    name: \"jhon\",\n    salary: 4000,\n    [Symbol.toPrimitive](hint){\n        console.log(hint);\n        return hint == 'string' ? this.name : this.salary;\n    }\n}\n\nconsole.log(+user) // number -&gt; 4000\nconsole.log(`${user}`) // string -&gt; jhon\nconsole.log(user + 2) // default -&gt; 4002   \n\n///\nlet usrz = {\n    name: \"dani\",\n    age: 15,\n    toString(){\n        console.log(\"inside toString...\");\n        return `toString -&gt; ${this.name}`\n    },\n    valueOf(){\n        console.log(\"inside valueOf...\")\n        return this.age\n    }\n}\n\n`${usrz}` // inside toString...  -&gt; dani\n+usrz  // inside valueOf... -&gt; 15\nusrz + 1 // inside valueOf... -&gt; 15\n\n/* toString() and valueOf() must return a primitive and not an object */\n/* if toPrimitive doesn't return a primitive there will be an error */\n</code></pre>"},{"location":"Objects/#constructors-and-the-new-keyword","title":"constructors, and the new keyword","text":"<p>we can use constructors to create multiple similar objects, instead of using the regular {\u2026} syntax.</p> <p>constructor are like any other functions except for being called with the new operator and starting with capital letters.</p> <pre><code>function User(name, age) { \n    // this = {} ;implicitly\n        this.name = name;\n        this.age = age;\n        this.happy = true;\n        // we can also add methods\n        this.smile = function(){ console.log(\"Smiling..\") }\n    // return this; implicitly\n}\n\nlet usr1 = new User(\"dani\", 20);\n</code></pre> <p>To create a single object with new</p> <pre><code>let user = new function(){ this.name ... }\n</code></pre> <p>To know if a function got called with new or not we can user new.target </p> <pre><code>let funky = function() {\n    if(new.target) return \"called with new\";\n    return \"called without\";\n}\n\nfunky() // called without\nnew funky() // called with new\n\n// this can be used to make functions a constructor regardless of the use of new\nfunction User(name) {\n    this.name = name;\n    if(!new.target) return new User(name)\n}\n</code></pre>  \ud83d\udc49\ud83c\udfff Return in Constructors   <p>if there is a return in a constructor, and it returns an object , it will override this by returning the object, and if a primitive is returned it will be ignored.</p>  \ud83d\udc49\ud83c\udfff We can omit parenthesis if constructor has no arguments   <pre><code>function Man() { this.sex = 'male' }\nlet man = new Man\n</code></pre>"},{"location":"Prototypes%20and%20Inheritance/","title":"Prototypal inheritance","text":"<p>Objects have a hidden specification property  [ [ Prototype ] ] that is either <code>null</code> or a referance to another object. If object B prototypically inherits from object A, and we try to read a property from B and it's missing, JS automatically tries to take it from A, this is called prototypal inheritance. Even though the [ [ Prototype] ] property is hidden, there are several ways to set it, one of them is <code>proto</code></p>"},{"location":"Prototypes%20and%20Inheritance/#proto","title":"<code>proto</code>","text":"<pre><code>let animal = {\n    move(){},\n    breate(){alert(\"moving\")}\n}\n\nlet mammal = {\n    giveBirth(){}\n    breastFeed(){}\n}\n\nmammal.__proto__ = animal;\nmammal.move() // moving\n\n// we can add other Objects which inherit from mammal\nlet avian = {\n    shitOnCars() {} \n    __proto__ : animal;\n}\n\n// we can make the inheritance chain longer\nlet human = {\n    __proto__: mammal;\n    inventStuff(){};\n}\n</code></pre> <p>The only limitations to inheritance are that </p> <ul> <li>References can't go in circles</li> <li>The value of <code>__proto__</code> can either be <code>null</code> or an object</li> </ul> <p>In modern language <code>proto</code> is replaced by methods like <code>Object.getPrototypeOf</code> and <code>Object.setPrototypeOf</code> </p> <p>If we try to write to inherited data properties we will simply be overriding them.</p> <pre><code>let animal = {\n    move(){\n        alert(\"animal on the move\");\n    }\n}\n\nlet mammal = {\n    __proto__: animal;\n}\n\nmammal.move = function(){\n    alert(\"A mammal on the move\");\n}\n\nmammal.move() // A mammal on the move\n</code></pre> <p>In prototypal inheritance methods can be shared but not object state i.e. <code>this</code> </p> <pre><code>let animal = {\n    walk(){\n        if(!this.isSleeping) alert(\"I'm walking\")\n    },\n    sleep(){\n        this.isSleeping = true;\n    }\n}\n\nlet rabbit = {\n    __proto__ : animal;\n    name: \"White Rabbit\"\n}\n\nrabit.sleep();\n\nrabit.isSleeping // true\nanimal.isSleeping // undefined\n</code></pre> for...in loop  A for...in loop iterates over inherited properties too."},{"location":"Prototypes%20and%20Inheritance/#objhasownpropertykey","title":"<code>obj.hasOwnProperty(key)</code>","text":"<p>This method returns true if <code>obj</code> has it's own uninherited property named <code>key</code> </p>"},{"location":"Prototypes%20and%20Inheritance/#fprototype","title":"F.prototype","text":"<p>The way Objects get prototypes when they are created with a constructor i.e. using the <code>new</code> keyword, is a bit different. Every function has a <code>prototype</code> property even if we don't supply it. And if <code>F.prototype</code> is an object, the new operator will automatically set it as the [ [prototype] ] for the new Object.</p> <pre><code>\nlet animal = {\n    eats: true;\n}\n\nlet Rabbit(name){\n    this.name = name;\n}\n\nRabbit.prototype = animal;\n\nlet rabbit = new Rabbit(\"Fluffy\");\n\nrabbit.eats // true\n</code></pre> If after the creation of the an object, the <code>prototype</code> of the constructor changes, the former object will retain the old prototype, but new object created with the constructor will have the new prototype <p>All objects have a <code>constructor</code> property.</p> <p>The default <code>prototype</code> for a function is an object with the only property <code>constructor</code> that points back to the function itself, like so.</p> <pre><code>\nlet Plant(species){\n    this.species = species;\n    this.hasRoot = true;\n\n    /* default prototype\n    this.prototype = {constructor: Plant}\n    */\n}\n\nlet rose = new Plant(\"Rosa\");\n\n// If we want to check which constructor rose was created with\nrose.constructor // \n[Function: Plant]\n</code></pre>"},{"location":"Prototypes%20and%20Inheritance/#native-prototypes","title":"Native prototypes","text":"<p>The <code>prototype</code> property is also widely used in the core of javascript as well.</p> <pre><code>let obj = {}\n\n// when obj is created the default new Object() constructor is used internally\n\nobj.constructor // [Function : Object]\n\nObject.prototype == obj.__proto__  // true\n\n// methods like toString() hasOwnProperty() etc, get inherited from the prototype\n// of the object constructor\n</code></pre> <p>Other built-in Objects such as <code>Array</code> <code>Date</code> and <code>Function</code> also keep their methods prototypes.  By specification all built in prototypes have <code>Object.prototype</code> at the top.</p> <p>![[Screenshot from 2022-07-30 13-02-17.png]]</p> <pre><code>\nlet arr = []\n\narr.__proto__ == Array.prototype // true\narr.__proto__.__proto__ == Object.prototype // true\narr.__proto__.__proto__.__proto__  // Null\n</code></pre>"},{"location":"Prototypes%20and%20Inheritance/#primitives","title":"primitives","text":"<p>Primitives are not objects, but if we try to access their properties, then temporary wrapper objects will be created using the built-in constructors <code>String</code> <code>Number</code> and <code>Boolean</code>. The methods of these objects also reside in prototypes. They are available as <code>String.prototype Number.prototype Boolean.prototype </code></p> values <code>null</code> and <code>undefined</code> stand apart in that they have no Object wrappers.  <p>We can modify native prototypes.</p> <pre><code>String.prototype.show = function(){\n    console.log(this.toString());\n}\n\n// the show() method will become available for all Strings\n\n\"Hello\".show()  // prints out Hello\n</code></pre>"},{"location":"The%20Basics/","title":"The Basics","text":"<p>If we give a <code>src</code> attribute inside our &lt;script&gt; tag, and at the same time define some code inside the &lt;script&gt; tags, the script inside will get ignored</p> <pre><code>&lt;script src=\"smt.js\"&gt;\n  console.log('hello'); // this code will get ignored\n&lt;/script&gt;\n</code></pre>  \ud83d\udca1 As a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files. The benefit of a separate file is that the browser will download it and store it in its cache. Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once. That reduces traffic and makes pages faster.  <pre><code>\"use strict\";\n// we can do ^ this to switch the engine to modern mode\n// they must be at the top\n// we can also use them in functions\n// several language features like classes and modules enable strict mode by default\n</code></pre> <p>we can declare multiple variables in one line</p> <pre><code>let name=\"jim\", age=8n, height=45.4n;\n</code></pre> \u26a0\ufe0f \u201cstrict\u201d mode alert     \ud83d\udd25 We could create variables without declaration merely through assignment, but this is not allowed in strict mode.  <p>Dynamically typed- there are datatypes but variables are not bound to them.</p>"},{"location":"The%20Basics/#the-7-basic-datatypes","title":"The 7 basic Datatypes","text":"<ul> <li>Number: integers and floating point numbers, plus Special numeric values (Infinity, -Infinity, NaN ).   Infinity is a result of division by 0. It\u2019s greater than any number.   NaN is the result of a computational error. If there is a NaN inside a mathematical expression it will propagate through the whole expression.   Doing math in JS is safe, i.e. it won\u2019t die with a fatal error, it will result in a NaN in the worst case</li> <li>Strings: can be surrounded with (\u201c\u201d), (\u2018\u2019) or backticks(``).</li> <li>Booleans: either true or false</li> <li>Null: In JS null is not a reference to a non-existing object, but an object of itself</li> <li>Undefined: Is also an object of it\u2019s own, and its assigned to variables which have been declared but not assigned, we can also explicitly assign it, but that\u2019s not good practice since that a job for null. null acts like a zero when used in operations. i.e. null - 5 == -5</li> <li>Objects</li> <li>Symbols: named objects</li> </ul>"},{"location":"The%20Basics/#the-typeof-operator","title":"The typeof operator","text":"<pre><code>&gt; let x = 5\n&gt; typeof x;  // as an operator\n&gt; typeof(x); // as a function\n</code></pre> <p>typeof(null) returns \u201cobject\u201d, This is an officially recognized error of JS, kept for compatibility. null is not an object but a special type of it\u2019s own .</p>"},{"location":"The%20Basics/#casting","title":"Casting","text":"<pre><code>// casting\n&gt; let x;\n&gt; x = String(x)  // To string\n&gt; x = \"45\" / true  // Numeric conversions happen automatically with operators\n&gt; x = Number(x)  // To Number\n// if one of the operands on + is a string, it will concatenate it\n&gt; \"45\" + 1 // 451\n&gt; x = Boolean(\"0\"); // true\n// casting for booleans, values which are intuitively empty(\"\", null, undefined, NaN)\n// get evaluated to false. note \"0\" and \" \" are evaluated to true\n</code></pre>"},{"location":"The%20Basics/#numeric-conversion-rules","title":"Numeric conversion rules \ud83d\udce2 The comma operator","text":"Value Becomes.. undefined NaN null 0 true and false 1 and 0 string Whitespaces from the start and end are removed. If the remaining string is empty, the result is 0. Otherwise, the number is \u201cread\u201d from the string. An error gives NaN  \ud83d\udd25 Tip : We can use the unary + to cast to Number.  <pre><code>let x = \"45\";\ntypeof +x; // Number\n+true; // 1\n</code></pre> <pre><code>// Weird stuff\n4 + 5 + \"px\"; // 9px\n\"px\" + 4 + 5; // px45\n// operations run from left to right\n</code></pre> <p>Unary operators have higher precedence than their binary counterparts.</p> <p>For more on operator precedence go to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</p> <p>Chained assignments are evaluated from right to left</p> <p>The assignment operator returns the value that it just assigned.</p> <pre><code>let a = 5;\n5 + (a = a + 5); // returns 15\n</code></pre> <pre><code>// Weird stuff\nlet a = 0;\nlet b = \"0\";\nBoolean(a) // false\nBoolean(b) // true\na == b // true\n// This happened because the == operator casts b to 0, and Boolean(b) returns true\n</code></pre> <p>Strict equality ( === )</p> <p>Strict equality operator, checks for equality without type conversion</p> <pre><code>null &gt; 0; // false\nnull &gt;= 0; // true\nnull == 0; // false  since equality doesn't cast null, like comparisions do\n\nnull == undefined; // true\nnull === undefined; // false\n</code></pre>  \u26a0\ufe0f Inside a switch cases are matched with strict equality ===   <pre><code>switch (\"3\") {\n  case 3: // this will not become true since their types are different\n}\n</code></pre> <p>The NOT ! operator</p> <p>! converts to a Boolean and returns its inverse</p>  \ud83d\udee0 Double NOT ( !! ) is used to cast to Boolean.  !!(\u201d0\u201d) // true        \ud83d\udce2 The comma operator <pre><code>// The comma operator evaluates all expressions and returns the last one\n    let a = ( 2 + 4, 3 + 8); // a will equal 11\n// the comma has lower precedence than even the =\nfor (a = 1, b = 3, c = a * b; a &lt; 10; a++) { ... }\n</code></pre>      \ud83d\udee0 The very special (OR ||) and (AND &amp;&amp;) operators <p>OR evaluates from left to right and returns the first truthy value, if none it returns the last \\ AND also evaluates from left to right and returns the first faulty value, if none it returns the last</p> <pre><code>result = value1 || value2 || value3;\n// result will be the first truthy value, if none it will be value3\n// &amp;&amp; has higher precedence than ||\n\nlet v1 = null;\nlet v2 = \"\";\n\nlet result = v1 || v2 || \"no-name\"; // no-name\nlet result = v1 &amp;&amp; v2 &amp;&amp; \"no-name\"; // null\n\n/* we can also use OR as an if statement due to them being short-circuit*/\ntrue || expression; // won't get evaluated\nfalse || expression; // gets evaluated\ntrue &amp;&amp; expression; // gets evaluated\nfalse &amp;&amp; expression; // won't get evaluated\n</code></pre>"},{"location":"The%20Basics/#functions","title":"Functions","text":"<pre><code>function smth(){ console.log(\"smth\") } // function declaration\nlet smth = function(){ } // function expression\nlet smth = () =&gt; {} // arrow functions,more concise than function expressions\n\n// we can specify parameters like\n\nfunction sayhello( person, message ) {\n    console.log( person + \" : \" + message )\n}\n\n// to specify a default value\nfunction sayHello( person, message = \"no message\") {}\n\n// we can assign the return of another function or expression as the default\nfunction sayHello ( person = expression , message = anotherFunction() )\n/* we can use the fact that the default expression or function call only gets executed\n     if the function is missing an argument */\n// another way we can assign default values is with\nfunction sayHello(person, message){\n    person = person || \"no-name\";\n    message = message || \"no-message\";\n}\n\n/* Functions can be copied, passed to other functions in which case they are called\n callbacks ... */\n\n</code></pre>  \u26a0\ufe0f In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter. In the example above, anotherFunction() is called every time showMessage() is called without the text parameter. This is in contrast to some other languages like Python, where any default parameters are evaluated only once during the initial interpretation.   <p>An empty or no-return returns undefined</p> <pre><code>function a() {\n  return;\n} // a() -&gt; undefined\nfunction b() {} // b() -&gt; undefined\n</code></pre> <p>http://127.0.0.1:8000/ Modal function - pause the code execution until they finish eg. alert() \u2026</p>  \u26a0\ufe0f  function declaration VS Function expression:  Functions initiated with function expressions can only be used after they have been declared, unlike those with function declarations. In other words. A Function Expression is created when the execution reaches it and is usable only from that moment. \u26a0\ufe0f \u201cstrict\u201d mode alert In strict mode functions will only be visible inside the block they were defined in."}]}